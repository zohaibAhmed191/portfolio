/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/outlayer";
exports.ids = ["vendor-chunks/outlayer"];
exports.modules = {

/***/ "(ssr)/./node_modules/outlayer/item.js":
/*!***************************************!*\
  !*** ./node_modules/outlayer/item.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Outlayer Item\n */ (function(window1, factory) {\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\")\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(EvEmitter, getSize) {\n    \"use strict\";\n    // ----- helpers ----- //\n    function isEmptyObj(obj) {\n        for(var prop in obj){\n            return false;\n        }\n        prop = null;\n        return true;\n    }\n    // -------------------------- CSS3 support -------------------------- //\n    var docElemStyle = document.documentElement.style;\n    var transitionProperty = typeof docElemStyle.transition == \"string\" ? \"transition\" : \"WebkitTransition\";\n    var transformProperty = typeof docElemStyle.transform == \"string\" ? \"transform\" : \"WebkitTransform\";\n    var transitionEndEvent = {\n        WebkitTransition: \"webkitTransitionEnd\",\n        transition: \"transitionend\"\n    }[transitionProperty];\n    // cache all vendor properties that could have vendor prefix\n    var vendorProperties = {\n        transform: transformProperty,\n        transition: transitionProperty,\n        transitionDuration: transitionProperty + \"Duration\",\n        transitionProperty: transitionProperty + \"Property\",\n        transitionDelay: transitionProperty + \"Delay\"\n    };\n    // -------------------------- Item -------------------------- //\n    function Item(element, layout) {\n        if (!element) {\n            return;\n        }\n        this.element = element;\n        // parent layout class, i.e. Masonry, Isotope, or Packery\n        this.layout = layout;\n        this.position = {\n            x: 0,\n            y: 0\n        };\n        this._create();\n    }\n    // inherit EvEmitter\n    var proto = Item.prototype = Object.create(EvEmitter.prototype);\n    proto.constructor = Item;\n    proto._create = function() {\n        // transition objects\n        this._transn = {\n            ingProperties: {},\n            clean: {},\n            onEnd: {}\n        };\n        this.css({\n            position: \"absolute\"\n        });\n    };\n    // trigger specified handler for event type\n    proto.handleEvent = function(event) {\n        var method = \"on\" + event.type;\n        if (this[method]) {\n            this[method](event);\n        }\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * apply CSS styles to element\n * @param {Object} style\n */ proto.css = function(style) {\n        var elemStyle = this.element.style;\n        for(var prop in style){\n            // use vendor property if available\n            var supportedProp = vendorProperties[prop] || prop;\n            elemStyle[supportedProp] = style[prop];\n        }\n    };\n    // measure position, and sets it\n    proto.getPosition = function() {\n        var style = getComputedStyle(this.element);\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        var xValue = style[isOriginLeft ? \"left\" : \"right\"];\n        var yValue = style[isOriginTop ? \"top\" : \"bottom\"];\n        var x = parseFloat(xValue);\n        var y = parseFloat(yValue);\n        // convert percent to pixels\n        var layoutSize = this.layout.size;\n        if (xValue.indexOf(\"%\") != -1) {\n            x = x / 100 * layoutSize.width;\n        }\n        if (yValue.indexOf(\"%\") != -1) {\n            y = y / 100 * layoutSize.height;\n        }\n        // clean up 'auto' or other non-integer values\n        x = isNaN(x) ? 0 : x;\n        y = isNaN(y) ? 0 : y;\n        // remove padding from measurement\n        x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;\n        y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;\n        this.position.x = x;\n        this.position.y = y;\n    };\n    // set settled position, apply padding\n    proto.layoutPosition = function() {\n        var layoutSize = this.layout.size;\n        var style = {};\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        // x\n        var xPadding = isOriginLeft ? \"paddingLeft\" : \"paddingRight\";\n        var xProperty = isOriginLeft ? \"left\" : \"right\";\n        var xResetProperty = isOriginLeft ? \"right\" : \"left\";\n        var x = this.position.x + layoutSize[xPadding];\n        // set in percentage or pixels\n        style[xProperty] = this.getXValue(x);\n        // reset other property\n        style[xResetProperty] = \"\";\n        // y\n        var yPadding = isOriginTop ? \"paddingTop\" : \"paddingBottom\";\n        var yProperty = isOriginTop ? \"top\" : \"bottom\";\n        var yResetProperty = isOriginTop ? \"bottom\" : \"top\";\n        var y = this.position.y + layoutSize[yPadding];\n        // set in percentage or pixels\n        style[yProperty] = this.getYValue(y);\n        // reset other property\n        style[yResetProperty] = \"\";\n        this.css(style);\n        this.emitEvent(\"layout\", [\n            this\n        ]);\n    };\n    proto.getXValue = function(x) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && !isHorizontal ? x / this.layout.size.width * 100 + \"%\" : x + \"px\";\n    };\n    proto.getYValue = function(y) {\n        var isHorizontal = this.layout._getOption(\"horizontal\");\n        return this.layout.options.percentPosition && isHorizontal ? y / this.layout.size.height * 100 + \"%\" : y + \"px\";\n    };\n    proto._transitionTo = function(x, y) {\n        this.getPosition();\n        // get current x & y from top/left\n        var curX = this.position.x;\n        var curY = this.position.y;\n        var didNotMove = x == this.position.x && y == this.position.y;\n        // save end position\n        this.setPosition(x, y);\n        // if did not move and not transitioning, just go to layout\n        if (didNotMove && !this.isTransitioning) {\n            this.layoutPosition();\n            return;\n        }\n        var transX = x - curX;\n        var transY = y - curY;\n        var transitionStyle = {};\n        transitionStyle.transform = this.getTranslate(transX, transY);\n        this.transition({\n            to: transitionStyle,\n            onTransitionEnd: {\n                transform: this.layoutPosition\n            },\n            isCleaning: true\n        });\n    };\n    proto.getTranslate = function(x, y) {\n        // flip cooridinates if origin on right or bottom\n        var isOriginLeft = this.layout._getOption(\"originLeft\");\n        var isOriginTop = this.layout._getOption(\"originTop\");\n        x = isOriginLeft ? x : -x;\n        y = isOriginTop ? y : -y;\n        return \"translate3d(\" + x + \"px, \" + y + \"px, 0)\";\n    };\n    // non transition + transform support\n    proto.goTo = function(x, y) {\n        this.setPosition(x, y);\n        this.layoutPosition();\n    };\n    proto.moveTo = proto._transitionTo;\n    proto.setPosition = function(x, y) {\n        this.position.x = parseFloat(x);\n        this.position.y = parseFloat(y);\n    };\n    // ----- transition ----- //\n    /**\n * @param {Object} style - CSS\n * @param {Function} onTransitionEnd\n */ // non transition, just trigger callback\n    proto._nonTransition = function(args) {\n        this.css(args.to);\n        if (args.isCleaning) {\n            this._removeStyles(args.to);\n        }\n        for(var prop in args.onTransitionEnd){\n            args.onTransitionEnd[prop].call(this);\n        }\n    };\n    /**\n * proper transition\n * @param {Object} args - arguments\n *   @param {Object} to - style to transition to\n *   @param {Object} from - style to start transition from\n *   @param {Boolean} isCleaning - removes transition styles after transition\n *   @param {Function} onTransitionEnd - callback\n */ proto.transition = function(args) {\n        // redirect to nonTransition if no transition duration\n        if (!parseFloat(this.layout.options.transitionDuration)) {\n            this._nonTransition(args);\n            return;\n        }\n        var _transition = this._transn;\n        // keep track of onTransitionEnd callback by css property\n        for(var prop in args.onTransitionEnd){\n            _transition.onEnd[prop] = args.onTransitionEnd[prop];\n        }\n        // keep track of properties that are transitioning\n        for(prop in args.to){\n            _transition.ingProperties[prop] = true;\n            // keep track of properties to clean up when transition is done\n            if (args.isCleaning) {\n                _transition.clean[prop] = true;\n            }\n        }\n        // set from styles\n        if (args.from) {\n            this.css(args.from);\n            // force redraw. http://blog.alexmaccaw.com/css-transitions\n            var h = this.element.offsetHeight;\n            // hack for JSHint to hush about unused var\n            h = null;\n        }\n        // enable transition\n        this.enableTransition(args.to);\n        // set styles that are transitioning\n        this.css(args.to);\n        this.isTransitioning = true;\n    };\n    // dash before all cap letters, including first for\n    // WebkitTransform => -webkit-transform\n    function toDashedAll(str) {\n        return str.replace(/([A-Z])/g, function($1) {\n            return \"-\" + $1.toLowerCase();\n        });\n    }\n    var transitionProps = \"opacity,\" + toDashedAll(transformProperty);\n    proto.enableTransition = function() {\n        // HACK changing transitionProperty during a transition\n        // will cause transition to jump\n        if (this.isTransitioning) {\n            return;\n        }\n        // make `transition: foo, bar, baz` from style object\n        // HACK un-comment this when enableTransition can work\n        // while a transition is happening\n        // var transitionValues = [];\n        // for ( var prop in style ) {\n        //   // dash-ify camelCased properties like WebkitTransition\n        //   prop = vendorProperties[ prop ] || prop;\n        //   transitionValues.push( toDashedAll( prop ) );\n        // }\n        // munge number to millisecond, to match stagger\n        var duration = this.layout.options.transitionDuration;\n        duration = typeof duration == \"number\" ? duration + \"ms\" : duration;\n        // enable transition styles\n        this.css({\n            transitionProperty: transitionProps,\n            transitionDuration: duration,\n            transitionDelay: this.staggerDelay || 0\n        });\n        // listen for transition end event\n        this.element.addEventListener(transitionEndEvent, this, false);\n    };\n    // ----- events ----- //\n    proto.onwebkitTransitionEnd = function(event) {\n        this.ontransitionend(event);\n    };\n    proto.onotransitionend = function(event) {\n        this.ontransitionend(event);\n    };\n    // properties that I munge to make my life easier\n    var dashedVendorProperties = {\n        \"-webkit-transform\": \"transform\"\n    };\n    proto.ontransitionend = function(event) {\n        // disregard bubbled events from children\n        if (event.target !== this.element) {\n            return;\n        }\n        var _transition = this._transn;\n        // get property name of transitioned property, convert to prefix-free\n        var propertyName = dashedVendorProperties[event.propertyName] || event.propertyName;\n        // remove property that has completed transitioning\n        delete _transition.ingProperties[propertyName];\n        // check if any properties are still transitioning\n        if (isEmptyObj(_transition.ingProperties)) {\n            // all properties have completed transitioning\n            this.disableTransition();\n        }\n        // clean style\n        if (propertyName in _transition.clean) {\n            // clean up style\n            this.element.style[event.propertyName] = \"\";\n            delete _transition.clean[propertyName];\n        }\n        // trigger onTransitionEnd callback\n        if (propertyName in _transition.onEnd) {\n            var onTransitionEnd = _transition.onEnd[propertyName];\n            onTransitionEnd.call(this);\n            delete _transition.onEnd[propertyName];\n        }\n        this.emitEvent(\"transitionEnd\", [\n            this\n        ]);\n    };\n    proto.disableTransition = function() {\n        this.removeTransitionStyles();\n        this.element.removeEventListener(transitionEndEvent, this, false);\n        this.isTransitioning = false;\n    };\n    /**\n * removes style property from element\n * @param {Object} style\n**/ proto._removeStyles = function(style) {\n        // clean up transition styles\n        var cleanStyle = {};\n        for(var prop in style){\n            cleanStyle[prop] = \"\";\n        }\n        this.css(cleanStyle);\n    };\n    var cleanTransitionStyle = {\n        transitionProperty: \"\",\n        transitionDuration: \"\",\n        transitionDelay: \"\"\n    };\n    proto.removeTransitionStyles = function() {\n        // remove transition\n        this.css(cleanTransitionStyle);\n    };\n    // ----- stagger ----- //\n    proto.stagger = function(delay) {\n        delay = isNaN(delay) ? 0 : delay;\n        this.staggerDelay = delay + \"ms\";\n    };\n    // ----- show/hide/remove ----- //\n    // remove element from DOM\n    proto.removeElem = function() {\n        this.element.parentNode.removeChild(this.element);\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        this.emitEvent(\"remove\", [\n            this\n        ]);\n    };\n    proto.remove = function() {\n        // just remove element if no transition support or no transition\n        if (!transitionProperty || !parseFloat(this.layout.options.transitionDuration)) {\n            this.removeElem();\n            return;\n        }\n        // start transition\n        this.once(\"transitionEnd\", function() {\n            this.removeElem();\n        });\n        this.hide();\n    };\n    proto.reveal = function() {\n        delete this.isHidden;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"visibleStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onRevealTransitionEnd;\n        this.transition({\n            from: options.hiddenStyle,\n            to: options.visibleStyle,\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onRevealTransitionEnd = function() {\n        // check if still visible\n        // during transition, item may have been hidden\n        if (!this.isHidden) {\n            this.emitEvent(\"reveal\");\n        }\n    };\n    /**\n * get style property use for hide/reveal transition end\n * @param {String} styleProperty - hiddenStyle/visibleStyle\n * @returns {String}\n */ proto.getHideRevealTransitionEndProperty = function(styleProperty) {\n        var optionStyle = this.layout.options[styleProperty];\n        // use opacity\n        if (optionStyle.opacity) {\n            return \"opacity\";\n        }\n        // get first property\n        for(var prop in optionStyle){\n            return prop;\n        }\n    };\n    proto.hide = function() {\n        // set flag\n        this.isHidden = true;\n        // remove display: none\n        this.css({\n            display: \"\"\n        });\n        var options = this.layout.options;\n        var onTransitionEnd = {};\n        var transitionEndProperty = this.getHideRevealTransitionEndProperty(\"hiddenStyle\");\n        onTransitionEnd[transitionEndProperty] = this.onHideTransitionEnd;\n        this.transition({\n            from: options.visibleStyle,\n            to: options.hiddenStyle,\n            // keep hidden stuff hidden\n            isCleaning: true,\n            onTransitionEnd: onTransitionEnd\n        });\n    };\n    proto.onHideTransitionEnd = function() {\n        // check if still hidden\n        // during transition, item may have been un-hidden\n        if (this.isHidden) {\n            this.css({\n                display: \"none\"\n            });\n            this.emitEvent(\"hide\");\n        }\n    };\n    proto.destroy = function() {\n        this.css({\n            position: \"\",\n            left: \"\",\n            right: \"\",\n            top: \"\",\n            bottom: \"\",\n            transition: \"\",\n            transform: \"\"\n        });\n    };\n    return Item;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3V0bGF5ZXIvaXRlbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVDLFVBQVVBLE9BQU0sRUFBRUMsT0FBTztJQUN6Qiw4QkFBOEI7SUFDOUIsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQzlELElBQUssSUFBeUMsRUFBRztRQUMvQyxrQkFBa0I7UUFDbEJDLGlDQUFRO1lBQ0o7WUFDQTtTQUNELG9DQUNERCxPQUFPQTtBQUFBO0FBQUE7QUFBQSxrR0FBQUE7SUFFWCxPQUFPLEVBYU47QUFFSCxHQUFHRCxRQUFRLFNBQVNDLFFBQVNRLFNBQVMsRUFBRUMsT0FBTztJQUMvQztJQUVBLHlCQUF5QjtJQUV6QixTQUFTQyxXQUFZQyxHQUFHO1FBQ3RCLElBQU0sSUFBSUMsUUFBUUQsSUFBTTtZQUN0QixPQUFPO1FBQ1Q7UUFDQUMsT0FBTztRQUNQLE9BQU87SUFDVDtJQUVBLHdFQUF3RTtJQUd4RSxJQUFJQyxlQUFlQyxTQUFTQyxlQUFlLENBQUNDLEtBQUs7SUFFakQsSUFBSUMscUJBQXFCLE9BQU9KLGFBQWFLLFVBQVUsSUFBSSxXQUN6RCxlQUFlO0lBQ2pCLElBQUlDLG9CQUFvQixPQUFPTixhQUFhTyxTQUFTLElBQUksV0FDdkQsY0FBYztJQUVoQixJQUFJQyxxQkFBcUI7UUFDdkJDLGtCQUFrQjtRQUNsQkosWUFBWTtJQUNkLENBQUMsQ0FBRUQsbUJBQW9CO0lBRXZCLDREQUE0RDtJQUM1RCxJQUFJTSxtQkFBbUI7UUFDckJILFdBQVdEO1FBQ1hELFlBQVlEO1FBQ1pPLG9CQUFvQlAscUJBQXFCO1FBQ3pDQSxvQkFBb0JBLHFCQUFxQjtRQUN6Q1EsaUJBQWlCUixxQkFBcUI7SUFDeEM7SUFFQSxnRUFBZ0U7SUFFaEUsU0FBU1YsS0FBTW1CLE9BQU8sRUFBRUMsTUFBTTtRQUM1QixJQUFLLENBQUNELFNBQVU7WUFDZDtRQUNGO1FBRUEsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YseURBQXlEO1FBQ3pELElBQUksQ0FB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NEMsc0JBQXVCLEdBQUcsSUFBSSxDQUFDUSxtQkFBbUI7UUFFbkUsSUFBSSxDQUFDNUgsVUFBVSxDQUFDO1lBQ2RpRixNQUFNdEIsUUFBUTZELFlBQVk7WUFDMUJqRCxJQUFJWixRQUFRNEQsV0FBVztZQUN2QiwyQkFBMkI7WUFDM0I5QyxZQUFZO1lBQ1pELGlCQUFpQkE7UUFDbkI7SUFDRjtJQUVBMUQsTUFBTThHLG1CQUFtQixHQUFHO1FBQzFCLHdCQUF3QjtRQUN4QixrREFBa0Q7UUFDbEQsSUFBSyxJQUFJLENBQUNULFFBQVEsRUFBRztZQUNuQixJQUFJLENBQUM1RixHQUFHLENBQUM7Z0JBQUV1RixTQUFTO1lBQU87WUFDM0IsSUFBSSxDQUFDckQsU0FBUyxDQUFDO1FBQ2pCO0lBQ0Y7SUFFQTNDLE1BQU0rRyxPQUFPLEdBQUc7UUFDZCxJQUFJLENBQUN0RyxHQUFHLENBQUM7WUFDUGIsVUFBVTtZQUNWb0gsTUFBTTtZQUNOQyxPQUFPO1lBQ1BDLEtBQUs7WUFDTEMsUUFBUTtZQUNSakksWUFBWTtZQUNaRSxXQUFXO1FBQ2I7SUFDRjtJQUVBLE9BQU9iO0FBRVAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3hmb2xpby8uL25vZGVfbW9kdWxlcy9vdXRsYXllci9pdGVtLmpzPzlhNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPdXRsYXllciBJdGVtXG4gKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRCAtIFJlcXVpcmVKU1xuICAgIGRlZmluZSggW1xuICAgICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJyxcbiAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJ1xuICAgICAgXSxcbiAgICAgIGZhY3RvcnlcbiAgICApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTIC0gQnJvd3NlcmlmeSwgV2VicGFja1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKSxcbiAgICAgIHJlcXVpcmUoJ2dldC1zaXplJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93Lk91dGxheWVyID0ge307XG4gICAgd2luZG93Lk91dGxheWVyLkl0ZW0gPSBmYWN0b3J5KFxuICAgICAgd2luZG93LkV2RW1pdHRlcixcbiAgICAgIHdpbmRvdy5nZXRTaXplXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIEV2RW1pdHRlciwgZ2V0U2l6ZSApIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0gaGVscGVycyAtLS0tLSAvL1xuXG5mdW5jdGlvbiBpc0VtcHR5T2JqKCBvYmogKSB7XG4gIGZvciAoIHZhciBwcm9wIGluIG9iaiApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvcCA9IG51bGw7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBDU1MzIHN1cHBvcnQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuXG52YXIgZG9jRWxlbVN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG52YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gdHlwZW9mIGRvY0VsZW1TdHlsZS50cmFuc2l0aW9uID09ICdzdHJpbmcnID9cbiAgJ3RyYW5zaXRpb24nIDogJ1dlYmtpdFRyYW5zaXRpb24nO1xudmFyIHRyYW5zZm9ybVByb3BlcnR5ID0gdHlwZW9mIGRvY0VsZW1TdHlsZS50cmFuc2Zvcm0gPT0gJ3N0cmluZycgP1xuICAndHJhbnNmb3JtJyA6ICdXZWJraXRUcmFuc2Zvcm0nO1xuXG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0ge1xuICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xufVsgdHJhbnNpdGlvblByb3BlcnR5IF07XG5cbi8vIGNhY2hlIGFsbCB2ZW5kb3IgcHJvcGVydGllcyB0aGF0IGNvdWxkIGhhdmUgdmVuZG9yIHByZWZpeFxudmFyIHZlbmRvclByb3BlcnRpZXMgPSB7XG4gIHRyYW5zZm9ybTogdHJhbnNmb3JtUHJvcGVydHksXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25Qcm9wZXJ0eSxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uUHJvcGVydHkgKyAnRHVyYXRpb24nLFxuICB0cmFuc2l0aW9uUHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wZXJ0eSArICdQcm9wZXJ0eScsXG4gIHRyYW5zaXRpb25EZWxheTogdHJhbnNpdGlvblByb3BlcnR5ICsgJ0RlbGF5J1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSXRlbSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBJdGVtKCBlbGVtZW50LCBsYXlvdXQgKSB7XG4gIGlmICggIWVsZW1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgLy8gcGFyZW50IGxheW91dCBjbGFzcywgaS5lLiBNYXNvbnJ5LCBJc290b3BlLCBvciBQYWNrZXJ5XG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICB0aGlzLnBvc2l0aW9uID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG4vLyBpbmhlcml0IEV2RW1pdHRlclxudmFyIHByb3RvID0gSXRlbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5wcm90by5jb25zdHJ1Y3RvciA9IEl0ZW07XG5cbnByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gdHJhbnNpdGlvbiBvYmplY3RzXG4gIHRoaXMuX3RyYW5zbiA9IHtcbiAgICBpbmdQcm9wZXJ0aWVzOiB7fSxcbiAgICBjbGVhbjoge30sXG4gICAgb25FbmQ6IHt9XG4gIH07XG5cbiAgdGhpcy5jc3Moe1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gIH0pO1xufTtcblxuLy8gdHJpZ2dlciBzcGVjaWZpZWQgaGFuZGxlciBmb3IgZXZlbnQgdHlwZVxucHJvdG8uaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBtZXRob2QgPSAnb24nICsgZXZlbnQudHlwZTtcbiAgaWYgKCB0aGlzWyBtZXRob2QgXSApIHtcbiAgICB0aGlzWyBtZXRob2QgXSggZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8uZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogYXBwbHkgQ1NTIHN0eWxlcyB0byBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqL1xucHJvdG8uY3NzID0gZnVuY3Rpb24oIHN0eWxlICkge1xuICB2YXIgZWxlbVN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlO1xuXG4gIGZvciAoIHZhciBwcm9wIGluIHN0eWxlICkge1xuICAgIC8vIHVzZSB2ZW5kb3IgcHJvcGVydHkgaWYgYXZhaWxhYmxlXG4gICAgdmFyIHN1cHBvcnRlZFByb3AgPSB2ZW5kb3JQcm9wZXJ0aWVzWyBwcm9wIF0gfHwgcHJvcDtcbiAgICBlbGVtU3R5bGVbIHN1cHBvcnRlZFByb3AgXSA9IHN0eWxlWyBwcm9wIF07XG4gIH1cbn07XG5cbiAvLyBtZWFzdXJlIHBvc2l0aW9uLCBhbmQgc2V0cyBpdFxucHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbGVtZW50ICk7XG4gIHZhciBpc09yaWdpbkxlZnQgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5MZWZ0Jyk7XG4gIHZhciBpc09yaWdpblRvcCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpblRvcCcpO1xuICB2YXIgeFZhbHVlID0gc3R5bGVbIGlzT3JpZ2luTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCcgXTtcbiAgdmFyIHlWYWx1ZSA9IHN0eWxlWyBpc09yaWdpblRvcCA/ICd0b3AnIDogJ2JvdHRvbScgXTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KCB4VmFsdWUgKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KCB5VmFsdWUgKTtcbiAgLy8gY29udmVydCBwZXJjZW50IHRvIHBpeGVsc1xuICB2YXIgbGF5b3V0U2l6ZSA9IHRoaXMubGF5b3V0LnNpemU7XG4gIGlmICggeFZhbHVlLmluZGV4T2YoJyUnKSAhPSAtMSApIHtcbiAgICB4ID0gKCB4IC8gMTAwICkgKiBsYXlvdXRTaXplLndpZHRoO1xuICB9XG4gIGlmICggeVZhbHVlLmluZGV4T2YoJyUnKSAhPSAtMSApIHtcbiAgICB5ID0gKCB5IC8gMTAwICkgKiBsYXlvdXRTaXplLmhlaWdodDtcbiAgfVxuICAvLyBjbGVhbiB1cCAnYXV0bycgb3Igb3RoZXIgbm9uLWludGVnZXIgdmFsdWVzXG4gIHggPSBpc05hTiggeCApID8gMCA6IHg7XG4gIHkgPSBpc05hTiggeSApID8gMCA6IHk7XG4gIC8vIHJlbW92ZSBwYWRkaW5nIGZyb20gbWVhc3VyZW1lbnRcbiAgeCAtPSBpc09yaWdpbkxlZnQgPyBsYXlvdXRTaXplLnBhZGRpbmdMZWZ0IDogbGF5b3V0U2l6ZS5wYWRkaW5nUmlnaHQ7XG4gIHkgLT0gaXNPcmlnaW5Ub3AgPyBsYXlvdXRTaXplLnBhZGRpbmdUb3AgOiBsYXlvdXRTaXplLnBhZGRpbmdCb3R0b207XG5cbiAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgdGhpcy5wb3NpdGlvbi55ID0geTtcbn07XG5cbi8vIHNldCBzZXR0bGVkIHBvc2l0aW9uLCBhcHBseSBwYWRkaW5nXG5wcm90by5sYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGF5b3V0U2l6ZSA9IHRoaXMubGF5b3V0LnNpemU7XG4gIHZhciBzdHlsZSA9IHt9O1xuICB2YXIgaXNPcmlnaW5MZWZ0ID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luTGVmdCcpO1xuICB2YXIgaXNPcmlnaW5Ub3AgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdvcmlnaW5Ub3AnKTtcblxuICAvLyB4XG4gIHZhciB4UGFkZGluZyA9IGlzT3JpZ2luTGVmdCA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcbiAgdmFyIHhQcm9wZXJ0eSA9IGlzT3JpZ2luTGVmdCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHZhciB4UmVzZXRQcm9wZXJ0eSA9IGlzT3JpZ2luTGVmdCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cbiAgdmFyIHggPSB0aGlzLnBvc2l0aW9uLnggKyBsYXlvdXRTaXplWyB4UGFkZGluZyBdO1xuICAvLyBzZXQgaW4gcGVyY2VudGFnZSBvciBwaXhlbHNcbiAgc3R5bGVbIHhQcm9wZXJ0eSBdID0gdGhpcy5nZXRYVmFsdWUoIHggKTtcbiAgLy8gcmVzZXQgb3RoZXIgcHJvcGVydHlcbiAgc3R5bGVbIHhSZXNldFByb3BlcnR5IF0gPSAnJztcblxuICAvLyB5XG4gIHZhciB5UGFkZGluZyA9IGlzT3JpZ2luVG9wID8gJ3BhZGRpbmdUb3AnIDogJ3BhZGRpbmdCb3R0b20nO1xuICB2YXIgeVByb3BlcnR5ID0gaXNPcmlnaW5Ub3AgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgeVJlc2V0UHJvcGVydHkgPSBpc09yaWdpblRvcCA/ICdib3R0b20nIDogJ3RvcCc7XG5cbiAgdmFyIHkgPSB0aGlzLnBvc2l0aW9uLnkgKyBsYXlvdXRTaXplWyB5UGFkZGluZyBdO1xuICAvLyBzZXQgaW4gcGVyY2VudGFnZSBvciBwaXhlbHNcbiAgc3R5bGVbIHlQcm9wZXJ0eSBdID0gdGhpcy5nZXRZVmFsdWUoIHkgKTtcbiAgLy8gcmVzZXQgb3RoZXIgcHJvcGVydHlcbiAgc3R5bGVbIHlSZXNldFByb3BlcnR5IF0gPSAnJztcblxuICB0aGlzLmNzcyggc3R5bGUgKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdsYXlvdXQnLCBbIHRoaXMgXSApO1xufTtcblxucHJvdG8uZ2V0WFZhbHVlID0gZnVuY3Rpb24oIHggKSB7XG4gIHZhciBpc0hvcml6b250YWwgPSB0aGlzLmxheW91dC5fZ2V0T3B0aW9uKCdob3Jpem9udGFsJyk7XG4gIHJldHVybiB0aGlzLmxheW91dC5vcHRpb25zLnBlcmNlbnRQb3NpdGlvbiAmJiAhaXNIb3Jpem9udGFsID9cbiAgICAoICggeCAvIHRoaXMubGF5b3V0LnNpemUud2lkdGggKSAqIDEwMCApICsgJyUnIDogeCArICdweCc7XG59O1xuXG5wcm90by5nZXRZVmFsdWUgPSBmdW5jdGlvbiggeSApIHtcbiAgdmFyIGlzSG9yaXpvbnRhbCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ2hvcml6b250YWwnKTtcbiAgcmV0dXJuIHRoaXMubGF5b3V0Lm9wdGlvbnMucGVyY2VudFBvc2l0aW9uICYmIGlzSG9yaXpvbnRhbCA/XG4gICAgKCAoIHkgLyB0aGlzLmxheW91dC5zaXplLmhlaWdodCApICogMTAwICkgKyAnJScgOiB5ICsgJ3B4Jztcbn07XG5cbnByb3RvLl90cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5nZXRQb3NpdGlvbigpO1xuICAvLyBnZXQgY3VycmVudCB4ICYgeSBmcm9tIHRvcC9sZWZ0XG4gIHZhciBjdXJYID0gdGhpcy5wb3NpdGlvbi54O1xuICB2YXIgY3VyWSA9IHRoaXMucG9zaXRpb24ueTtcblxuICB2YXIgZGlkTm90TW92ZSA9IHggPT0gdGhpcy5wb3NpdGlvbi54ICYmIHkgPT0gdGhpcy5wb3NpdGlvbi55O1xuXG4gIC8vIHNhdmUgZW5kIHBvc2l0aW9uXG4gIHRoaXMuc2V0UG9zaXRpb24oIHgsIHkgKTtcblxuICAvLyBpZiBkaWQgbm90IG1vdmUgYW5kIG5vdCB0cmFuc2l0aW9uaW5nLCBqdXN0IGdvIHRvIGxheW91dFxuICBpZiAoIGRpZE5vdE1vdmUgJiYgIXRoaXMuaXNUcmFuc2l0aW9uaW5nICkge1xuICAgIHRoaXMubGF5b3V0UG9zaXRpb24oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdHJhbnNYID0geCAtIGN1clg7XG4gIHZhciB0cmFuc1kgPSB5IC0gY3VyWTtcbiAgdmFyIHRyYW5zaXRpb25TdHlsZSA9IHt9O1xuICB0cmFuc2l0aW9uU3R5bGUudHJhbnNmb3JtID0gdGhpcy5nZXRUcmFuc2xhdGUoIHRyYW5zWCwgdHJhbnNZICk7XG5cbiAgdGhpcy50cmFuc2l0aW9uKHtcbiAgICB0bzogdHJhbnNpdGlvblN0eWxlLFxuICAgIG9uVHJhbnNpdGlvbkVuZDoge1xuICAgICAgdHJhbnNmb3JtOiB0aGlzLmxheW91dFBvc2l0aW9uXG4gICAgfSxcbiAgICBpc0NsZWFuaW5nOiB0cnVlXG4gIH0pO1xufTtcblxucHJvdG8uZ2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIC8vIGZsaXAgY29vcmlkaW5hdGVzIGlmIG9yaWdpbiBvbiByaWdodCBvciBib3R0b21cbiAgdmFyIGlzT3JpZ2luTGVmdCA9IHRoaXMubGF5b3V0Ll9nZXRPcHRpb24oJ29yaWdpbkxlZnQnKTtcbiAgdmFyIGlzT3JpZ2luVG9wID0gdGhpcy5sYXlvdXQuX2dldE9wdGlvbignb3JpZ2luVG9wJyk7XG4gIHggPSBpc09yaWdpbkxlZnQgPyB4IDogLXg7XG4gIHkgPSBpc09yaWdpblRvcCA/IHkgOiAteTtcbiAgcmV0dXJuICd0cmFuc2xhdGUzZCgnICsgeCArICdweCwgJyArIHkgKyAncHgsIDApJztcbn07XG5cbi8vIG5vbiB0cmFuc2l0aW9uICsgdHJhbnNmb3JtIHN1cHBvcnRcbnByb3RvLmdvVG8gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5zZXRQb3NpdGlvbiggeCwgeSApO1xuICB0aGlzLmxheW91dFBvc2l0aW9uKCk7XG59O1xuXG5wcm90by5tb3ZlVG8gPSBwcm90by5fdHJhbnNpdGlvblRvO1xuXG5wcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICB0aGlzLnBvc2l0aW9uLnggPSBwYXJzZUZsb2F0KCB4ICk7XG4gIHRoaXMucG9zaXRpb24ueSA9IHBhcnNlRmxvYXQoIHkgKTtcbn07XG5cbi8vIC0tLS0tIHRyYW5zaXRpb24gLS0tLS0gLy9cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGUgLSBDU1NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVHJhbnNpdGlvbkVuZFxuICovXG5cbi8vIG5vbiB0cmFuc2l0aW9uLCBqdXN0IHRyaWdnZXIgY2FsbGJhY2tcbnByb3RvLl9ub25UcmFuc2l0aW9uID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG4gIHRoaXMuY3NzKCBhcmdzLnRvICk7XG4gIGlmICggYXJncy5pc0NsZWFuaW5nICkge1xuICAgIHRoaXMuX3JlbW92ZVN0eWxlcyggYXJncy50byApO1xuICB9XG4gIGZvciAoIHZhciBwcm9wIGluIGFyZ3Mub25UcmFuc2l0aW9uRW5kICkge1xuICAgIGFyZ3Mub25UcmFuc2l0aW9uRW5kWyBwcm9wIF0uY2FsbCggdGhpcyApO1xuICB9XG59O1xuXG4vKipcbiAqIHByb3BlciB0cmFuc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncyAtIGFyZ3VtZW50c1xuICogICBAcGFyYW0ge09iamVjdH0gdG8gLSBzdHlsZSB0byB0cmFuc2l0aW9uIHRvXG4gKiAgIEBwYXJhbSB7T2JqZWN0fSBmcm9tIC0gc3R5bGUgdG8gc3RhcnQgdHJhbnNpdGlvbiBmcm9tXG4gKiAgIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbGVhbmluZyAtIHJlbW92ZXMgdHJhbnNpdGlvbiBzdHlsZXMgYWZ0ZXIgdHJhbnNpdGlvblxuICogICBAcGFyYW0ge0Z1bmN0aW9ufSBvblRyYW5zaXRpb25FbmQgLSBjYWxsYmFja1xuICovXG5wcm90by50cmFuc2l0aW9uID0gZnVuY3Rpb24oIGFyZ3MgKSB7XG4gIC8vIHJlZGlyZWN0IHRvIG5vblRyYW5zaXRpb24gaWYgbm8gdHJhbnNpdGlvbiBkdXJhdGlvblxuICBpZiAoICFwYXJzZUZsb2F0KCB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiApICkge1xuICAgIHRoaXMuX25vblRyYW5zaXRpb24oIGFyZ3MgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX3RyYW5zaXRpb24gPSB0aGlzLl90cmFuc247XG4gIC8vIGtlZXAgdHJhY2sgb2Ygb25UcmFuc2l0aW9uRW5kIGNhbGxiYWNrIGJ5IGNzcyBwcm9wZXJ0eVxuICBmb3IgKCB2YXIgcHJvcCBpbiBhcmdzLm9uVHJhbnNpdGlvbkVuZCApIHtcbiAgICBfdHJhbnNpdGlvbi5vbkVuZFsgcHJvcCBdID0gYXJncy5vblRyYW5zaXRpb25FbmRbIHByb3AgXTtcbiAgfVxuICAvLyBrZWVwIHRyYWNrIG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgdHJhbnNpdGlvbmluZ1xuICBmb3IgKCBwcm9wIGluIGFyZ3MudG8gKSB7XG4gICAgX3RyYW5zaXRpb24uaW5nUHJvcGVydGllc1sgcHJvcCBdID0gdHJ1ZTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHByb3BlcnRpZXMgdG8gY2xlYW4gdXAgd2hlbiB0cmFuc2l0aW9uIGlzIGRvbmVcbiAgICBpZiAoIGFyZ3MuaXNDbGVhbmluZyApIHtcbiAgICAgIF90cmFuc2l0aW9uLmNsZWFuWyBwcm9wIF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBmcm9tIHN0eWxlc1xuICBpZiAoIGFyZ3MuZnJvbSApIHtcbiAgICB0aGlzLmNzcyggYXJncy5mcm9tICk7XG4gICAgLy8gZm9yY2UgcmVkcmF3LiBodHRwOi8vYmxvZy5hbGV4bWFjY2F3LmNvbS9jc3MtdHJhbnNpdGlvbnNcbiAgICB2YXIgaCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgLy8gaGFjayBmb3IgSlNIaW50IHRvIGh1c2ggYWJvdXQgdW51c2VkIHZhclxuICAgIGggPSBudWxsO1xuICB9XG4gIC8vIGVuYWJsZSB0cmFuc2l0aW9uXG4gIHRoaXMuZW5hYmxlVHJhbnNpdGlvbiggYXJncy50byApO1xuICAvLyBzZXQgc3R5bGVzIHRoYXQgYXJlIHRyYW5zaXRpb25pbmdcbiAgdGhpcy5jc3MoIGFyZ3MudG8gKTtcblxuICB0aGlzLmlzVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbn07XG5cbi8vIGRhc2ggYmVmb3JlIGFsbCBjYXAgbGV0dGVycywgaW5jbHVkaW5nIGZpcnN0IGZvclxuLy8gV2Via2l0VHJhbnNmb3JtID0+IC13ZWJraXQtdHJhbnNmb3JtXG5mdW5jdGlvbiB0b0Rhc2hlZEFsbCggc3RyICkge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoIC8oW0EtWl0pL2csIGZ1bmN0aW9uKCAkMSApIHtcbiAgICByZXR1cm4gJy0nICsgJDEudG9Mb3dlckNhc2UoKTtcbiAgfSk7XG59XG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSAnb3BhY2l0eSwnICsgdG9EYXNoZWRBbGwoIHRyYW5zZm9ybVByb3BlcnR5ICk7XG5cbnByb3RvLmVuYWJsZVRyYW5zaXRpb24gPSBmdW5jdGlvbigvKiBzdHlsZSAqLykge1xuICAvLyBIQUNLIGNoYW5naW5nIHRyYW5zaXRpb25Qcm9wZXJ0eSBkdXJpbmcgYSB0cmFuc2l0aW9uXG4gIC8vIHdpbGwgY2F1c2UgdHJhbnNpdGlvbiB0byBqdW1wXG4gIGlmICggdGhpcy5pc1RyYW5zaXRpb25pbmcgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gbWFrZSBgdHJhbnNpdGlvbjogZm9vLCBiYXIsIGJhemAgZnJvbSBzdHlsZSBvYmplY3RcbiAgLy8gSEFDSyB1bi1jb21tZW50IHRoaXMgd2hlbiBlbmFibGVUcmFuc2l0aW9uIGNhbiB3b3JrXG4gIC8vIHdoaWxlIGEgdHJhbnNpdGlvbiBpcyBoYXBwZW5pbmdcbiAgLy8gdmFyIHRyYW5zaXRpb25WYWx1ZXMgPSBbXTtcbiAgLy8gZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gIC8vICAgLy8gZGFzaC1pZnkgY2FtZWxDYXNlZCBwcm9wZXJ0aWVzIGxpa2UgV2Via2l0VHJhbnNpdGlvblxuICAvLyAgIHByb3AgPSB2ZW5kb3JQcm9wZXJ0aWVzWyBwcm9wIF0gfHwgcHJvcDtcbiAgLy8gICB0cmFuc2l0aW9uVmFsdWVzLnB1c2goIHRvRGFzaGVkQWxsKCBwcm9wICkgKTtcbiAgLy8gfVxuICAvLyBtdW5nZSBudW1iZXIgdG8gbWlsbGlzZWNvbmQsIHRvIG1hdGNoIHN0YWdnZXJcbiAgdmFyIGR1cmF0aW9uID0gdGhpcy5sYXlvdXQub3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb247XG4gIGR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09ICdudW1iZXInID8gZHVyYXRpb24gKyAnbXMnIDogZHVyYXRpb247XG4gIC8vIGVuYWJsZSB0cmFuc2l0aW9uIHN0eWxlc1xuICB0aGlzLmNzcyh7XG4gICAgdHJhbnNpdGlvblByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICB0cmFuc2l0aW9uRGVsYXk6IHRoaXMuc3RhZ2dlckRlbGF5IHx8IDBcbiAgfSk7XG4gIC8vIGxpc3RlbiBmb3IgdHJhbnNpdGlvbiBlbmQgZXZlbnRcbiAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHRyYW5zaXRpb25FbmRFdmVudCwgdGhpcywgZmFsc2UgKTtcbn07XG5cbi8vIC0tLS0tIGV2ZW50cyAtLS0tLSAvL1xuXG5wcm90by5vbndlYmtpdFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHRoaXMub250cmFuc2l0aW9uZW5kKCBldmVudCApO1xufTtcblxucHJvdG8ub25vdHJhbnNpdGlvbmVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5vbnRyYW5zaXRpb25lbmQoIGV2ZW50ICk7XG59O1xuXG4vLyBwcm9wZXJ0aWVzIHRoYXQgSSBtdW5nZSB0byBtYWtlIG15IGxpZmUgZWFzaWVyXG52YXIgZGFzaGVkVmVuZG9yUHJvcGVydGllcyA9IHtcbiAgJy13ZWJraXQtdHJhbnNmb3JtJzogJ3RyYW5zZm9ybSdcbn07XG5cbnByb3RvLm9udHJhbnNpdGlvbmVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gZGlzcmVnYXJkIGJ1YmJsZWQgZXZlbnRzIGZyb20gY2hpbGRyZW5cbiAgaWYgKCBldmVudC50YXJnZXQgIT09IHRoaXMuZWxlbWVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIF90cmFuc2l0aW9uID0gdGhpcy5fdHJhbnNuO1xuICAvLyBnZXQgcHJvcGVydHkgbmFtZSBvZiB0cmFuc2l0aW9uZWQgcHJvcGVydHksIGNvbnZlcnQgdG8gcHJlZml4LWZyZWVcbiAgdmFyIHByb3BlcnR5TmFtZSA9IGRhc2hlZFZlbmRvclByb3BlcnRpZXNbIGV2ZW50LnByb3BlcnR5TmFtZSBdIHx8IGV2ZW50LnByb3BlcnR5TmFtZTtcblxuICAvLyByZW1vdmUgcHJvcGVydHkgdGhhdCBoYXMgY29tcGxldGVkIHRyYW5zaXRpb25pbmdcbiAgZGVsZXRlIF90cmFuc2l0aW9uLmluZ1Byb3BlcnRpZXNbIHByb3BlcnR5TmFtZSBdO1xuICAvLyBjaGVjayBpZiBhbnkgcHJvcGVydGllcyBhcmUgc3RpbGwgdHJhbnNpdGlvbmluZ1xuICBpZiAoIGlzRW1wdHlPYmooIF90cmFuc2l0aW9uLmluZ1Byb3BlcnRpZXMgKSApIHtcbiAgICAvLyBhbGwgcHJvcGVydGllcyBoYXZlIGNvbXBsZXRlZCB0cmFuc2l0aW9uaW5nXG4gICAgdGhpcy5kaXNhYmxlVHJhbnNpdGlvbigpO1xuICB9XG4gIC8vIGNsZWFuIHN0eWxlXG4gIGlmICggcHJvcGVydHlOYW1lIGluIF90cmFuc2l0aW9uLmNsZWFuICkge1xuICAgIC8vIGNsZWFuIHVwIHN0eWxlXG4gICAgdGhpcy5lbGVtZW50LnN0eWxlWyBldmVudC5wcm9wZXJ0eU5hbWUgXSA9ICcnO1xuICAgIGRlbGV0ZSBfdHJhbnNpdGlvbi5jbGVhblsgcHJvcGVydHlOYW1lIF07XG4gIH1cbiAgLy8gdHJpZ2dlciBvblRyYW5zaXRpb25FbmQgY2FsbGJhY2tcbiAgaWYgKCBwcm9wZXJ0eU5hbWUgaW4gX3RyYW5zaXRpb24ub25FbmQgKSB7XG4gICAgdmFyIG9uVHJhbnNpdGlvbkVuZCA9IF90cmFuc2l0aW9uLm9uRW5kWyBwcm9wZXJ0eU5hbWUgXTtcbiAgICBvblRyYW5zaXRpb25FbmQuY2FsbCggdGhpcyApO1xuICAgIGRlbGV0ZSBfdHJhbnNpdGlvbi5vbkVuZFsgcHJvcGVydHlOYW1lIF07XG4gIH1cblxuICB0aGlzLmVtaXRFdmVudCggJ3RyYW5zaXRpb25FbmQnLCBbIHRoaXMgXSApO1xufTtcblxucHJvdG8uZGlzYWJsZVRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVUcmFuc2l0aW9uU3R5bGVzKCk7XG4gIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0cmFuc2l0aW9uRW5kRXZlbnQsIHRoaXMsIGZhbHNlICk7XG4gIHRoaXMuaXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIHJlbW92ZXMgc3R5bGUgcHJvcGVydHkgZnJvbSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbioqL1xucHJvdG8uX3JlbW92ZVN0eWxlcyA9IGZ1bmN0aW9uKCBzdHlsZSApIHtcbiAgLy8gY2xlYW4gdXAgdHJhbnNpdGlvbiBzdHlsZXNcbiAgdmFyIGNsZWFuU3R5bGUgPSB7fTtcbiAgZm9yICggdmFyIHByb3AgaW4gc3R5bGUgKSB7XG4gICAgY2xlYW5TdHlsZVsgcHJvcCBdID0gJyc7XG4gIH1cbiAgdGhpcy5jc3MoIGNsZWFuU3R5bGUgKTtcbn07XG5cbnZhciBjbGVhblRyYW5zaXRpb25TdHlsZSA9IHtcbiAgdHJhbnNpdGlvblByb3BlcnR5OiAnJyxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAnJyxcbiAgdHJhbnNpdGlvbkRlbGF5OiAnJ1xufTtcblxucHJvdG8ucmVtb3ZlVHJhbnNpdGlvblN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAvLyByZW1vdmUgdHJhbnNpdGlvblxuICB0aGlzLmNzcyggY2xlYW5UcmFuc2l0aW9uU3R5bGUgKTtcbn07XG5cbi8vIC0tLS0tIHN0YWdnZXIgLS0tLS0gLy9cblxucHJvdG8uc3RhZ2dlciA9IGZ1bmN0aW9uKCBkZWxheSApIHtcbiAgZGVsYXkgPSBpc05hTiggZGVsYXkgKSA/IDAgOiBkZWxheTtcbiAgdGhpcy5zdGFnZ2VyRGVsYXkgPSBkZWxheSArICdtcyc7XG59O1xuXG4vLyAtLS0tLSBzaG93L2hpZGUvcmVtb3ZlIC0tLS0tIC8vXG5cbi8vIHJlbW92ZSBlbGVtZW50IGZyb20gRE9NXG5wcm90by5yZW1vdmVFbGVtID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLmVsZW1lbnQgKTtcbiAgLy8gcmVtb3ZlIGRpc3BsYXk6IG5vbmVcbiAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnJyB9KTtcbiAgdGhpcy5lbWl0RXZlbnQoICdyZW1vdmUnLCBbIHRoaXMgXSApO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGp1c3QgcmVtb3ZlIGVsZW1lbnQgaWYgbm8gdHJhbnNpdGlvbiBzdXBwb3J0IG9yIG5vIHRyYW5zaXRpb25cbiAgaWYgKCAhdHJhbnNpdGlvblByb3BlcnR5IHx8ICFwYXJzZUZsb2F0KCB0aGlzLmxheW91dC5vcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiApICkge1xuICAgIHRoaXMucmVtb3ZlRWxlbSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHN0YXJ0IHRyYW5zaXRpb25cbiAgdGhpcy5vbmNlKCAndHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlRWxlbSgpO1xuICB9KTtcbiAgdGhpcy5oaWRlKCk7XG59O1xuXG5wcm90by5yZXZlYWwgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMuaXNIaWRkZW47XG4gIC8vIHJlbW92ZSBkaXNwbGF5OiBub25lXG4gIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLmxheW91dC5vcHRpb25zO1xuXG4gIHZhciBvblRyYW5zaXRpb25FbmQgPSB7fTtcbiAgdmFyIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSA9IHRoaXMuZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSgndmlzaWJsZVN0eWxlJyk7XG4gIG9uVHJhbnNpdGlvbkVuZFsgdHJhbnNpdGlvbkVuZFByb3BlcnR5IF0gPSB0aGlzLm9uUmV2ZWFsVHJhbnNpdGlvbkVuZDtcblxuICB0aGlzLnRyYW5zaXRpb24oe1xuICAgIGZyb206IG9wdGlvbnMuaGlkZGVuU3R5bGUsXG4gICAgdG86IG9wdGlvbnMudmlzaWJsZVN0eWxlLFxuICAgIGlzQ2xlYW5pbmc6IHRydWUsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblRyYW5zaXRpb25FbmRcbiAgfSk7XG59O1xuXG5wcm90by5vblJldmVhbFRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2hlY2sgaWYgc3RpbGwgdmlzaWJsZVxuICAvLyBkdXJpbmcgdHJhbnNpdGlvbiwgaXRlbSBtYXkgaGF2ZSBiZWVuIGhpZGRlblxuICBpZiAoICF0aGlzLmlzSGlkZGVuICkge1xuICAgIHRoaXMuZW1pdEV2ZW50KCdyZXZlYWwnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgc3R5bGUgcHJvcGVydHkgdXNlIGZvciBoaWRlL3JldmVhbCB0cmFuc2l0aW9uIGVuZFxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlUHJvcGVydHkgLSBoaWRkZW5TdHlsZS92aXNpYmxlU3R5bGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbnByb3RvLmdldEhpZGVSZXZlYWxUcmFuc2l0aW9uRW5kUHJvcGVydHkgPSBmdW5jdGlvbiggc3R5bGVQcm9wZXJ0eSApIHtcbiAgdmFyIG9wdGlvblN0eWxlID0gdGhpcy5sYXlvdXQub3B0aW9uc1sgc3R5bGVQcm9wZXJ0eSBdO1xuICAvLyB1c2Ugb3BhY2l0eVxuICBpZiAoIG9wdGlvblN0eWxlLm9wYWNpdHkgKSB7XG4gICAgcmV0dXJuICdvcGFjaXR5JztcbiAgfVxuICAvLyBnZXQgZmlyc3QgcHJvcGVydHlcbiAgZm9yICggdmFyIHByb3AgaW4gb3B0aW9uU3R5bGUgKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn07XG5cbnByb3RvLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gc2V0IGZsYWdcbiAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XG4gIC8vIHJlbW92ZSBkaXNwbGF5OiBub25lXG4gIHRoaXMuY3NzKHsgZGlzcGxheTogJycgfSk7XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLmxheW91dC5vcHRpb25zO1xuXG4gIHZhciBvblRyYW5zaXRpb25FbmQgPSB7fTtcbiAgdmFyIHRyYW5zaXRpb25FbmRQcm9wZXJ0eSA9IHRoaXMuZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSgnaGlkZGVuU3R5bGUnKTtcbiAgb25UcmFuc2l0aW9uRW5kWyB0cmFuc2l0aW9uRW5kUHJvcGVydHkgXSA9IHRoaXMub25IaWRlVHJhbnNpdGlvbkVuZDtcblxuICB0aGlzLnRyYW5zaXRpb24oe1xuICAgIGZyb206IG9wdGlvbnMudmlzaWJsZVN0eWxlLFxuICAgIHRvOiBvcHRpb25zLmhpZGRlblN0eWxlLFxuICAgIC8vIGtlZXAgaGlkZGVuIHN0dWZmIGhpZGRlblxuICAgIGlzQ2xlYW5pbmc6IHRydWUsXG4gICAgb25UcmFuc2l0aW9uRW5kOiBvblRyYW5zaXRpb25FbmRcbiAgfSk7XG59O1xuXG5wcm90by5vbkhpZGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGlmIHN0aWxsIGhpZGRlblxuICAvLyBkdXJpbmcgdHJhbnNpdGlvbiwgaXRlbSBtYXkgaGF2ZSBiZWVuIHVuLWhpZGRlblxuICBpZiAoIHRoaXMuaXNIaWRkZW4gKSB7XG4gICAgdGhpcy5jc3MoeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgdGhpcy5lbWl0RXZlbnQoJ2hpZGUnKTtcbiAgfVxufTtcblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNzcyh7XG4gICAgcG9zaXRpb246ICcnLFxuICAgIGxlZnQ6ICcnLFxuICAgIHJpZ2h0OiAnJyxcbiAgICB0b3A6ICcnLFxuICAgIGJvdHRvbTogJycsXG4gICAgdHJhbnNpdGlvbjogJycsXG4gICAgdHJhbnNmb3JtOiAnJ1xuICB9KTtcbn07XG5cbnJldHVybiBJdGVtO1xuXG59KSk7XG4iXSwibmFtZXMiOlsid2luZG93IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiT3V0bGF5ZXIiLCJJdGVtIiwiRXZFbWl0dGVyIiwiZ2V0U2l6ZSIsImlzRW1wdHlPYmoiLCJvYmoiLCJwcm9wIiwiZG9jRWxlbVN0eWxlIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb24iLCJ0cmFuc2Zvcm1Qcm9wZXJ0eSIsInRyYW5zZm9ybSIsInRyYW5zaXRpb25FbmRFdmVudCIsIldlYmtpdFRyYW5zaXRpb24iLCJ2ZW5kb3JQcm9wZXJ0aWVzIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvbkRlbGF5IiwiZWxlbWVudCIsImxheW91dCIsInBvc2l0aW9uIiwieCIsInkiLCJfY3JlYXRlIiwicHJvdG8iLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIl90cmFuc24iLCJpbmdQcm9wZXJ0aWVzIiwiY2xlYW4iLCJvbkVuZCIsImNzcyIsImhhbmRsZUV2ZW50IiwiZXZlbnQiLCJtZXRob2QiLCJ0eXBlIiwic2l6ZSIsImVsZW1TdHlsZSIsInN1cHBvcnRlZFByb3AiLCJnZXRQb3NpdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJpc09yaWdpbkxlZnQiLCJfZ2V0T3B0aW9uIiwiaXNPcmlnaW5Ub3AiLCJ4VmFsdWUiLCJ5VmFsdWUiLCJwYXJzZUZsb2F0IiwibGF5b3V0U2l6ZSIsImluZGV4T2YiLCJ3aWR0aCIsImhlaWdodCIsImlzTmFOIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ0JvdHRvbSIsImxheW91dFBvc2l0aW9uIiwieFBhZGRpbmciLCJ4UHJvcGVydHkiLCJ4UmVzZXRQcm9wZXJ0eSIsImdldFhWYWx1ZSIsInlQYWRkaW5nIiwieVByb3BlcnR5IiwieVJlc2V0UHJvcGVydHkiLCJnZXRZVmFsdWUiLCJlbWl0RXZlbnQiLCJpc0hvcml6b250YWwiLCJvcHRpb25zIiwicGVyY2VudFBvc2l0aW9uIiwiX3RyYW5zaXRpb25UbyIsImN1clgiLCJjdXJZIiwiZGlkTm90TW92ZSIsInNldFBvc2l0aW9uIiwiaXNUcmFuc2l0aW9uaW5nIiwidHJhbnNYIiwidHJhbnNZIiwidHJhbnNpdGlvblN0eWxlIiwiZ2V0VHJhbnNsYXRlIiwidG8iLCJvblRyYW5zaXRpb25FbmQiLCJpc0NsZWFuaW5nIiwiZ29UbyIsIm1vdmVUbyIsIl9ub25UcmFuc2l0aW9uIiwiYXJncyIsIl9yZW1vdmVTdHlsZXMiLCJjYWxsIiwiX3RyYW5zaXRpb24iLCJmcm9tIiwiaCIsIm9mZnNldEhlaWdodCIsImVuYWJsZVRyYW5zaXRpb24iLCJ0b0Rhc2hlZEFsbCIsInN0ciIsInJlcGxhY2UiLCIkMSIsInRvTG93ZXJDYXNlIiwidHJhbnNpdGlvblByb3BzIiwiZHVyYXRpb24iLCJzdGFnZ2VyRGVsYXkiLCJhZGRFdmVudExpc3RlbmVyIiwib253ZWJraXRUcmFuc2l0aW9uRW5kIiwib250cmFuc2l0aW9uZW5kIiwib25vdHJhbnNpdGlvbmVuZCIsImRhc2hlZFZlbmRvclByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wZXJ0eU5hbWUiLCJkaXNhYmxlVHJhbnNpdGlvbiIsInJlbW92ZVRyYW5zaXRpb25TdHlsZXMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xlYW5TdHlsZSIsImNsZWFuVHJhbnNpdGlvblN0eWxlIiwic3RhZ2dlciIsImRlbGF5IiwicmVtb3ZlRWxlbSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImRpc3BsYXkiLCJyZW1vdmUiLCJvbmNlIiwiaGlkZSIsInJldmVhbCIsImlzSGlkZGVuIiwidHJhbnNpdGlvbkVuZFByb3BlcnR5IiwiZ2V0SGlkZVJldmVhbFRyYW5zaXRpb25FbmRQcm9wZXJ0eSIsIm9uUmV2ZWFsVHJhbnNpdGlvbkVuZCIsImhpZGRlblN0eWxlIiwidmlzaWJsZVN0eWxlIiwic3R5bGVQcm9wZXJ0eSIsIm9wdGlvblN0eWxlIiwib3BhY2l0eSIsIm9uSGlkZVRyYW5zaXRpb25FbmQiLCJkZXN0cm95IiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/item.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/outlayer/outlayer.js":
/*!*******************************************!*\
  !*** ./node_modules/outlayer/outlayer.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Outlayer v2.1.1\n * the brains and guts of a layout library\n * MIT license\n */ (function(window1, factory) {\n    \"use strict\";\n    // universal module definition\n    /* jshint strict: false */ /* globals define, module, require */ if (true) {\n        // AMD - RequireJS\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! ev-emitter/ev-emitter */ \"(ssr)/./node_modules/ev-emitter/ev-emitter.js\"),\n            __webpack_require__(/*! get-size/get-size */ \"(ssr)/./node_modules/get-size/get-size.js\"),\n            __webpack_require__(/*! fizzy-ui-utils/utils */ \"(ssr)/./node_modules/fizzy-ui-utils/utils.js\"),\n            __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/outlayer/item.js\")\n        ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(EvEmitter, getSize, utils, Item) {\n            return factory(window1, EvEmitter, getSize, utils, Item);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(window, function factory(window1, EvEmitter, getSize, utils, Item) {\n    \"use strict\";\n    // ----- vars ----- //\n    var console = window1.console;\n    var jQuery = window1.jQuery;\n    var noop = function() {};\n    // -------------------------- Outlayer -------------------------- //\n    // globally unique identifiers\n    var GUID = 0;\n    // internal store of all Outlayer intances\n    var instances = {};\n    /**\n * @param {Element, String} element\n * @param {Object} options\n * @constructor\n */ function Outlayer(element, options) {\n        var queryElement = utils.getQueryElement(element);\n        if (!queryElement) {\n            if (console) {\n                console.error(\"Bad element for \" + this.constructor.namespace + \": \" + (queryElement || element));\n            }\n            return;\n        }\n        this.element = queryElement;\n        // add jQuery\n        if (jQuery) {\n            this.$element = jQuery(this.element);\n        }\n        // options\n        this.options = utils.extend({}, this.constructor.defaults);\n        this.option(options);\n        // add id for Outlayer.getFromElement\n        var id = ++GUID;\n        this.element.outlayerGUID = id; // expando\n        instances[id] = this; // associate via id\n        // kick it off\n        this._create();\n        var isInitLayout = this._getOption(\"initLayout\");\n        if (isInitLayout) {\n            this.layout();\n        }\n    }\n    // settings are for internal use only\n    Outlayer.namespace = \"outlayer\";\n    Outlayer.Item = Item;\n    // default options\n    Outlayer.defaults = {\n        containerStyle: {\n            position: \"relative\"\n        },\n        initLayout: true,\n        originLeft: true,\n        originTop: true,\n        resize: true,\n        resizeContainer: true,\n        // item options\n        transitionDuration: \"0.4s\",\n        hiddenStyle: {\n            opacity: 0,\n            transform: \"scale(0.001)\"\n        },\n        visibleStyle: {\n            opacity: 1,\n            transform: \"scale(1)\"\n        }\n    };\n    var proto = Outlayer.prototype;\n    // inherit EvEmitter\n    utils.extend(proto, EvEmitter.prototype);\n    /**\n * set options\n * @param {Object} opts\n */ proto.option = function(opts) {\n        utils.extend(this.options, opts);\n    };\n    /**\n * get backwards compatible option value, check old name\n */ proto._getOption = function(option) {\n        var oldOption = this.constructor.compatOptions[option];\n        return oldOption && this.options[oldOption] !== undefined ? this.options[oldOption] : this.options[option];\n    };\n    Outlayer.compatOptions = {\n        // currentName: oldName\n        initLayout: \"isInitLayout\",\n        horizontal: \"isHorizontal\",\n        layoutInstant: \"isLayoutInstant\",\n        originLeft: \"isOriginLeft\",\n        originTop: \"isOriginTop\",\n        resize: \"isResizeBound\",\n        resizeContainer: \"isResizingContainer\"\n    };\n    proto._create = function() {\n        // get items from children\n        this.reloadItems();\n        // elements that affect layout, but are not laid out\n        this.stamps = [];\n        this.stamp(this.options.stamp);\n        // set container style\n        utils.extend(this.element.style, this.options.containerStyle);\n        // bind resize method\n        var canBindResize = this._getOption(\"resize\");\n        if (canBindResize) {\n            this.bindResize();\n        }\n    };\n    // goes through all children again and gets bricks in proper order\n    proto.reloadItems = function() {\n        // collection of item elements\n        this.items = this._itemize(this.element.children);\n    };\n    /**\n * turn elements into Outlayer.Items to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - collection of new Outlayer Items\n */ proto._itemize = function(elems) {\n        var itemElems = this._filterFindItemElements(elems);\n        var Item = this.constructor.Item;\n        // create new Outlayer Items for collection\n        var items = [];\n        for(var i = 0; i < itemElems.length; i++){\n            var elem = itemElems[i];\n            var item = new Item(elem, this);\n            items.push(item);\n        }\n        return items;\n    };\n    /**\n * get item elements to be used in layout\n * @param {Array or NodeList or HTMLElement} elems\n * @returns {Array} items - item elements\n */ proto._filterFindItemElements = function(elems) {\n        return utils.filterFindElements(elems, this.options.itemSelector);\n    };\n    /**\n * getter method for getting item elements\n * @returns {Array} elems - collection of item elements\n */ proto.getItemElements = function() {\n        return this.items.map(function(item) {\n            return item.element;\n        });\n    };\n    // ----- init & layout ----- //\n    /**\n * lays out all items\n */ proto.layout = function() {\n        this._resetLayout();\n        this._manageStamps();\n        // don't animate first layout\n        var layoutInstant = this._getOption(\"layoutInstant\");\n        var isInstant = layoutInstant !== undefined ? layoutInstant : !this._isLayoutInited;\n        this.layoutItems(this.items, isInstant);\n        // flag for initalized\n        this._isLayoutInited = true;\n    };\n    // _init is alias for layout\n    proto._init = proto.layout;\n    /**\n * logic before any new layout\n */ proto._resetLayout = function() {\n        this.getSize();\n    };\n    proto.getSize = function() {\n        this.size = getSize(this.element);\n    };\n    /**\n * get measurement from option, for columnWidth, rowHeight, gutter\n * if option is String -> get element from selector string, & get size of element\n * if option is Element -> get size of element\n * else use option as a number\n *\n * @param {String} measurement\n * @param {String} size - width or height\n * @private\n */ proto._getMeasurement = function(measurement, size) {\n        var option = this.options[measurement];\n        var elem;\n        if (!option) {\n            // default to 0\n            this[measurement] = 0;\n        } else {\n            // use option as an element\n            if (typeof option == \"string\") {\n                elem = this.element.querySelector(option);\n            } else if (option instanceof HTMLElement) {\n                elem = option;\n            }\n            // use size of element, if element\n            this[measurement] = elem ? getSize(elem)[size] : option;\n        }\n    };\n    /**\n * layout a collection of item elements\n * @api public\n */ proto.layoutItems = function(items, isInstant) {\n        items = this._getItemsForLayout(items);\n        this._layoutItems(items, isInstant);\n        this._postLayout();\n    };\n    /**\n * get the items to be laid out\n * you may want to skip over some items\n * @param {Array} items\n * @returns {Array} items\n */ proto._getItemsForLayout = function(items) {\n        return items.filter(function(item) {\n            return !item.isIgnored;\n        });\n    };\n    /**\n * layout items\n * @param {Array} items\n * @param {Boolean} isInstant\n */ proto._layoutItems = function(items, isInstant) {\n        this._emitCompleteOnItems(\"layout\", items);\n        if (!items || !items.length) {\n            // no items, emit event with empty array\n            return;\n        }\n        var queue = [];\n        items.forEach(function(item) {\n            // get x/y object from method\n            var position = this._getItemLayoutPosition(item);\n            // enqueue\n            position.item = item;\n            position.isInstant = isInstant || item.isLayoutInstant;\n            queue.push(position);\n        }, this);\n        this._processLayoutQueue(queue);\n    };\n    /**\n * get item layout position\n * @param {Outlayer.Item} item\n * @returns {Object} x and y position\n */ proto._getItemLayoutPosition = function() {\n        return {\n            x: 0,\n            y: 0\n        };\n    };\n    /**\n * iterate over array and position each item\n * Reason being - separating this logic prevents 'layout invalidation'\n * thx @paul_irish\n * @param {Array} queue\n */ proto._processLayoutQueue = function(queue) {\n        this.updateStagger();\n        queue.forEach(function(obj, i) {\n            this._positionItem(obj.item, obj.x, obj.y, obj.isInstant, i);\n        }, this);\n    };\n    // set stagger from option in milliseconds number\n    proto.updateStagger = function() {\n        var stagger = this.options.stagger;\n        if (stagger === null || stagger === undefined) {\n            this.stagger = 0;\n            return;\n        }\n        this.stagger = getMilliseconds(stagger);\n        return this.stagger;\n    };\n    /**\n * Sets position of item in DOM\n * @param {Outlayer.Item} item\n * @param {Number} x - horizontal position\n * @param {Number} y - vertical position\n * @param {Boolean} isInstant - disables transitions\n */ proto._positionItem = function(item, x, y, isInstant, i) {\n        if (isInstant) {\n            // if not transition, just set CSS\n            item.goTo(x, y);\n        } else {\n            item.stagger(i * this.stagger);\n            item.moveTo(x, y);\n        }\n    };\n    /**\n * Any logic you want to do after each layout,\n * i.e. size the container\n */ proto._postLayout = function() {\n        this.resizeContainer();\n    };\n    proto.resizeContainer = function() {\n        var isResizingContainer = this._getOption(\"resizeContainer\");\n        if (!isResizingContainer) {\n            return;\n        }\n        var size = this._getContainerSize();\n        if (size) {\n            this._setContainerMeasure(size.width, true);\n            this._setContainerMeasure(size.height, false);\n        }\n    };\n    /**\n * Sets width or height of container if returned\n * @returns {Object} size\n *   @param {Number} width\n *   @param {Number} height\n */ proto._getContainerSize = noop;\n    /**\n * @param {Number} measure - size of width or height\n * @param {Boolean} isWidth\n */ proto._setContainerMeasure = function(measure, isWidth) {\n        if (measure === undefined) {\n            return;\n        }\n        var elemSize = this.size;\n        // add padding and border width if border box\n        if (elemSize.isBorderBox) {\n            measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight + elemSize.borderLeftWidth + elemSize.borderRightWidth : elemSize.paddingBottom + elemSize.paddingTop + elemSize.borderTopWidth + elemSize.borderBottomWidth;\n        }\n        measure = Math.max(measure, 0);\n        this.element.style[isWidth ? \"width\" : \"height\"] = measure + \"px\";\n    };\n    /**\n * emit eventComplete on a collection of items events\n * @param {String} eventName\n * @param {Array} items - Outlayer.Items\n */ proto._emitCompleteOnItems = function(eventName, items) {\n        var _this = this;\n        function onComplete() {\n            _this.dispatchEvent(eventName + \"Complete\", null, [\n                items\n            ]);\n        }\n        var count = items.length;\n        if (!items || !count) {\n            onComplete();\n            return;\n        }\n        var doneCount = 0;\n        function tick() {\n            doneCount++;\n            if (doneCount == count) {\n                onComplete();\n            }\n        }\n        // bind callback\n        items.forEach(function(item) {\n            item.once(eventName, tick);\n        });\n    };\n    /**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */ proto.dispatchEvent = function(type, event, args) {\n        // add original event to arguments\n        var emitArgs = event ? [\n            event\n        ].concat(args) : args;\n        this.emitEvent(type, emitArgs);\n        if (jQuery) {\n            // set this.$element\n            this.$element = this.$element || jQuery(this.element);\n            if (event) {\n                // create jQuery event\n                var $event = jQuery.Event(event);\n                $event.type = type;\n                this.$element.trigger($event, args);\n            } else {\n                // just trigger with type if no event available\n                this.$element.trigger(type, args);\n            }\n        }\n    };\n    // -------------------------- ignore & stamps -------------------------- //\n    /**\n * keep item in collection, but do not lay it out\n * ignored items do not get skipped in layout\n * @param {Element} elem\n */ proto.ignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            item.isIgnored = true;\n        }\n    };\n    /**\n * return item to layout collection\n * @param {Element} elem\n */ proto.unignore = function(elem) {\n        var item = this.getItem(elem);\n        if (item) {\n            delete item.isIgnored;\n        }\n    };\n    /**\n * adds elements to stamps\n * @param {NodeList, Array, Element, or String} elems\n */ proto.stamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        this.stamps = this.stamps.concat(elems);\n        // ignore\n        elems.forEach(this.ignore, this);\n    };\n    /**\n * removes elements to stamps\n * @param {NodeList, Array, or Element} elems\n */ proto.unstamp = function(elems) {\n        elems = this._find(elems);\n        if (!elems) {\n            return;\n        }\n        elems.forEach(function(elem) {\n            // filter out removed stamp elements\n            utils.removeFrom(this.stamps, elem);\n            this.unignore(elem);\n        }, this);\n    };\n    /**\n * finds child elements\n * @param {NodeList, Array, Element, or String} elems\n * @returns {Array} elems\n */ proto._find = function(elems) {\n        if (!elems) {\n            return;\n        }\n        // if string, use argument as selector string\n        if (typeof elems == \"string\") {\n            elems = this.element.querySelectorAll(elems);\n        }\n        elems = utils.makeArray(elems);\n        return elems;\n    };\n    proto._manageStamps = function() {\n        if (!this.stamps || !this.stamps.length) {\n            return;\n        }\n        this._getBoundingRect();\n        this.stamps.forEach(this._manageStamp, this);\n    };\n    // update boundingLeft / Top\n    proto._getBoundingRect = function() {\n        // get bounding rect for container element\n        var boundingRect = this.element.getBoundingClientRect();\n        var size = this.size;\n        this._boundingRect = {\n            left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,\n            top: boundingRect.top + size.paddingTop + size.borderTopWidth,\n            right: boundingRect.right - (size.paddingRight + size.borderRightWidth),\n            bottom: boundingRect.bottom - (size.paddingBottom + size.borderBottomWidth)\n        };\n    };\n    /**\n * @param {Element} stamp\n**/ proto._manageStamp = noop;\n    /**\n * get x/y position of element relative to container element\n * @param {Element} elem\n * @returns {Object} offset - has left, top, right, bottom\n */ proto._getElementOffset = function(elem) {\n        var boundingRect = elem.getBoundingClientRect();\n        var thisRect = this._boundingRect;\n        var size = getSize(elem);\n        var offset = {\n            left: boundingRect.left - thisRect.left - size.marginLeft,\n            top: boundingRect.top - thisRect.top - size.marginTop,\n            right: thisRect.right - boundingRect.right - size.marginRight,\n            bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom\n        };\n        return offset;\n    };\n    // -------------------------- resize -------------------------- //\n    // enable event handlers for listeners\n    // i.e. resize -> onresize\n    proto.handleEvent = utils.handleEvent;\n    /**\n * Bind layout to window resizing\n */ proto.bindResize = function() {\n        window1.addEventListener(\"resize\", this);\n        this.isResizeBound = true;\n    };\n    /**\n * Unbind layout to window resizing\n */ proto.unbindResize = function() {\n        window1.removeEventListener(\"resize\", this);\n        this.isResizeBound = false;\n    };\n    proto.onresize = function() {\n        this.resize();\n    };\n    utils.debounceMethod(Outlayer, \"onresize\", 100);\n    proto.resize = function() {\n        // don't trigger if size did not change\n        // or if resize was unbound. See #9\n        if (!this.isResizeBound || !this.needsResizeLayout()) {\n            return;\n        }\n        this.layout();\n    };\n    /**\n * check if layout is needed post layout\n * @returns Boolean\n */ proto.needsResizeLayout = function() {\n        var size = getSize(this.element);\n        // check that this.size and size are there\n        // IE8 triggers resize on body size change, so they might not be\n        var hasSizes = this.size && size;\n        return hasSizes && size.innerWidth !== this.size.innerWidth;\n    };\n    // -------------------------- methods -------------------------- //\n    /**\n * add items to Outlayer instance\n * @param {Array or NodeList or Element} elems\n * @returns {Array} items - Outlayer.Items\n**/ proto.addItems = function(elems) {\n        var items = this._itemize(elems);\n        // add items to collection\n        if (items.length) {\n            this.items = this.items.concat(items);\n        }\n        return items;\n    };\n    /**\n * Layout newly-appended item elements\n * @param {Array or NodeList or Element} elems\n */ proto.appended = function(elems) {\n        var items = this.addItems(elems);\n        if (!items.length) {\n            return;\n        }\n        // layout and reveal just the new items\n        this.layoutItems(items, true);\n        this.reveal(items);\n    };\n    /**\n * Layout prepended elements\n * @param {Array or NodeList or Element} elems\n */ proto.prepended = function(elems) {\n        var items = this._itemize(elems);\n        if (!items.length) {\n            return;\n        }\n        // add items to beginning of collection\n        var previousItems = this.items.slice(0);\n        this.items = items.concat(previousItems);\n        // start new layout\n        this._resetLayout();\n        this._manageStamps();\n        // layout new stuff without transition\n        this.layoutItems(items, true);\n        this.reveal(items);\n        // layout previous items\n        this.layoutItems(previousItems);\n    };\n    /**\n * reveal a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.reveal = function(items) {\n        this._emitCompleteOnItems(\"reveal\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.reveal();\n        });\n    };\n    /**\n * hide a collection of items\n * @param {Array of Outlayer.Items} items\n */ proto.hide = function(items) {\n        this._emitCompleteOnItems(\"hide\", items);\n        if (!items || !items.length) {\n            return;\n        }\n        var stagger = this.updateStagger();\n        items.forEach(function(item, i) {\n            item.stagger(i * stagger);\n            item.hide();\n        });\n    };\n    /**\n * reveal item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.revealItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.reveal(items);\n    };\n    /**\n * hide item elements\n * @param {Array}, {Element}, {NodeList} items\n */ proto.hideItemElements = function(elems) {\n        var items = this.getItems(elems);\n        this.hide(items);\n    };\n    /**\n * get Outlayer.Item, given an Element\n * @param {Element} elem\n * @param {Function} callback\n * @returns {Outlayer.Item} item\n */ proto.getItem = function(elem) {\n        // loop through items to get the one that matches\n        for(var i = 0; i < this.items.length; i++){\n            var item = this.items[i];\n            if (item.element == elem) {\n                // return item\n                return item;\n            }\n        }\n    };\n    /**\n * get collection of Outlayer.Items, given Elements\n * @param {Array} elems\n * @returns {Array} items - Outlayer.Items\n */ proto.getItems = function(elems) {\n        elems = utils.makeArray(elems);\n        var items = [];\n        elems.forEach(function(elem) {\n            var item = this.getItem(elem);\n            if (item) {\n                items.push(item);\n            }\n        }, this);\n        return items;\n    };\n    /**\n * remove element(s) from instance and DOM\n * @param {Array or NodeList or Element} elems\n */ proto.remove = function(elems) {\n        var removeItems = this.getItems(elems);\n        this._emitCompleteOnItems(\"remove\", removeItems);\n        // bail if no items to remove\n        if (!removeItems || !removeItems.length) {\n            return;\n        }\n        removeItems.forEach(function(item) {\n            item.remove();\n            // remove item from collection\n            utils.removeFrom(this.items, item);\n        }, this);\n    };\n    // ----- destroy ----- //\n    // remove and disable Outlayer instance\n    proto.destroy = function() {\n        // clean up dynamic styles\n        var style = this.element.style;\n        style.height = \"\";\n        style.position = \"\";\n        style.width = \"\";\n        // destroy items\n        this.items.forEach(function(item) {\n            item.destroy();\n        });\n        this.unbindResize();\n        var id = this.element.outlayerGUID;\n        delete instances[id]; // remove reference to instance by id\n        delete this.element.outlayerGUID;\n        // remove data for jQuery\n        if (jQuery) {\n            jQuery.removeData(this.element, this.constructor.namespace);\n        }\n    };\n    // -------------------------- data -------------------------- //\n    /**\n * get Outlayer instance from element\n * @param {Element} elem\n * @returns {Outlayer}\n */ Outlayer.data = function(elem) {\n        elem = utils.getQueryElement(elem);\n        var id = elem && elem.outlayerGUID;\n        return id && instances[id];\n    };\n    // -------------------------- create Outlayer class -------------------------- //\n    /**\n * create a layout class\n * @param {String} namespace\n */ Outlayer.create = function(namespace, options) {\n        // sub-class Outlayer\n        var Layout = subclass(Outlayer);\n        // apply new options and compatOptions\n        Layout.defaults = utils.extend({}, Outlayer.defaults);\n        utils.extend(Layout.defaults, options);\n        Layout.compatOptions = utils.extend({}, Outlayer.compatOptions);\n        Layout.namespace = namespace;\n        Layout.data = Outlayer.data;\n        // sub-class Item\n        Layout.Item = subclass(Item);\n        // -------------------------- declarative -------------------------- //\n        utils.htmlInit(Layout, namespace);\n        // -------------------------- jQuery bridge -------------------------- //\n        // make into jQuery plugin\n        if (jQuery && jQuery.bridget) {\n            jQuery.bridget(namespace, Layout);\n        }\n        return Layout;\n    };\n    function subclass(Parent) {\n        function SubClass() {\n            Parent.apply(this, arguments);\n        }\n        SubClass.prototype = Object.create(Parent.prototype);\n        SubClass.prototype.constructor = SubClass;\n        return SubClass;\n    }\n    // ----- helpers ----- //\n    // how many milliseconds are in each unit\n    var msUnits = {\n        ms: 1,\n        s: 1000\n    };\n    // munge time-like parameter into millisecond number\n    // '0.4s' -> 40\n    function getMilliseconds(time) {\n        if (typeof time == \"number\") {\n            return time;\n        }\n        var matches = time.match(/(^\\d*\\.?\\d*)(\\w*)/);\n        var num = matches && matches[1];\n        var unit = matches && matches[2];\n        if (!num.length) {\n            return 0;\n        }\n        num = parseFloat(num);\n        var mult = msUnits[unit] || 1;\n        return num * mult;\n    }\n    // ----- fin ----- //\n    // back in global\n    Outlayer.Item = Item;\n    return Outlayer;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3V0bGF5ZXIvb3V0bGF5ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Q0FJQyxHQUVDLFVBQVVBLE9BQU0sRUFBRUMsT0FBTztJQUN6QjtJQUNBLDhCQUE4QjtJQUM5Qix3QkFBd0IsR0FBRyxtQ0FBbUMsR0FDOUQsSUFBSyxJQUF5QyxFQUFHO1FBQy9DLGtCQUFrQjtRQUNsQkMsaUNBQVE7WUFDSjtZQUNBO1lBQ0E7WUFDQTtTQUNELG1DQUNELFNBQVVFLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLElBQUk7WUFDdkMsT0FBT04sUUFBU0QsU0FBUUksV0FBV0MsU0FBU0MsT0FBT0M7UUFDckQsQ0FBQztBQUFBO0lBRUwsT0FBTyxFQWtCTjtBQUVILEdBQUdQLFFBQVEsU0FBU0MsUUFBU0QsT0FBTSxFQUFFSSxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQ3BFO0lBRUEsc0JBQXNCO0lBRXRCLElBQUlNLFVBQVViLFFBQU9hLE9BQU87SUFDNUIsSUFBSUMsU0FBU2QsUUFBT2MsTUFBTTtJQUMxQixJQUFJQyxPQUFPLFlBQVk7SUFFdkIsb0VBQW9FO0lBRXBFLDhCQUE4QjtJQUM5QixJQUFJQyxPQUFPO0lBQ1gsMENBQTBDO0lBQzFDLElBQUlDLFlBQVksQ0FBQztJQUdqQjs7OztDQUlDLEdBQ0QsU0FBU04sU0FBVU8sT0FBTyxFQUFFQyxPQUFPO1FBQ2pDLElBQUlDLGVBQWVkLE1BQU1lLGVBQWUsQ0FBRUg7UUFDMUMsSUFBSyxDQUFDRSxjQUFlO1lBQ25CLElBQUtQLFNBQVU7Z0JBQ2JBLFFBQVFTLEtBQUssQ0FBRSxxQkFBcUIsSUFBSSxDQUFDQyxXQUFXLENBQUNDLFNBQVMsR0FDNUQsT0FBU0osQ0FBQUEsZ0JBQWdCRixPQUFNO1lBQ25DO1lBQ0E7UUFDRjtRQUNBLElBQUksQ0FBQ0EsT0FBTyxHQUFHRTtRQUNmLGFBQWE7UUFDYixJQUFLTixRQUFTO1lBQ1osSUFBSSxDQUFD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QSxRQUFRLFVBQVc7WUFDN0IsT0FBT0E7UUFDVDtRQUNBLElBQUlDLFVBQVVELEtBQUtFLEtBQUssQ0FBRTtRQUMxQixJQUFJQyxNQUFNRixXQUFXQSxPQUFPLENBQUMsRUFBRTtRQUMvQixJQUFJRyxPQUFPSCxXQUFXQSxPQUFPLENBQUMsRUFBRTtRQUNoQyxJQUFLLENBQUNFLElBQUk1SSxNQUFNLEVBQUc7WUFDakIsT0FBTztRQUNUO1FBQ0E0SSxNQUFNRSxXQUFZRjtRQUNsQixJQUFJRyxPQUFPVCxPQUFPLENBQUVPLEtBQU0sSUFBSTtRQUM5QixPQUFPRCxNQUFNRztJQUNmO0lBRUEscUJBQXFCO0lBRXJCLGlCQUFpQjtJQUNqQnhNLFNBQVNKLElBQUksR0FBR0E7SUFFaEIsT0FBT0k7QUFFUCIsInNvdXJjZXMiOlsid2VicGFjazovL25veGZvbGlvLy4vbm9kZV9tb2R1bGVzL291dGxheWVyL291dGxheWVyLmpzPzMyMDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBPdXRsYXllciB2Mi4xLjFcbiAqIHRoZSBicmFpbnMgYW5kIGd1dHMgb2YgYSBsYXlvdXQgbGlicmFyeVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTUQgLSBSZXF1aXJlSlNcbiAgICBkZWZpbmUoIFtcbiAgICAgICAgJ2V2LWVtaXR0ZXIvZXYtZW1pdHRlcicsXG4gICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZScsXG4gICAgICAgICdmaXp6eS11aS11dGlscy91dGlscycsXG4gICAgICAgICcuL2l0ZW0nXG4gICAgICBdLFxuICAgICAgZnVuY3Rpb24oIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIEl0ZW0gKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciwgZ2V0U2l6ZSwgdXRpbHMsIEl0ZW0pO1xuICAgICAgfVxuICAgICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZXYtZW1pdHRlcicpLFxuICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKSxcbiAgICAgIHJlcXVpcmUoJ2Zpenp5LXVpLXV0aWxzJyksXG4gICAgICByZXF1aXJlKCcuL2l0ZW0nKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuT3V0bGF5ZXIgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LkV2RW1pdHRlcixcbiAgICAgIHdpbmRvdy5nZXRTaXplLFxuICAgICAgd2luZG93LmZpenp5VUlVdGlscyxcbiAgICAgIHdpbmRvdy5PdXRsYXllci5JdGVtXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyLCBnZXRTaXplLCB1dGlscywgSXRlbSApIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0gdmFycyAtLS0tLSAvL1xuXG52YXIgY29uc29sZSA9IHdpbmRvdy5jb25zb2xlO1xudmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE91dGxheWVyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGdsb2JhbGx5IHVuaXF1ZSBpZGVudGlmaWVyc1xudmFyIEdVSUQgPSAwO1xuLy8gaW50ZXJuYWwgc3RvcmUgb2YgYWxsIE91dGxheWVyIGludGFuY2VzXG52YXIgaW5zdGFuY2VzID0ge307XG5cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQsIFN0cmluZ30gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPdXRsYXllciggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgdmFyIHF1ZXJ5RWxlbWVudCA9IHV0aWxzLmdldFF1ZXJ5RWxlbWVudCggZWxlbWVudCApO1xuICBpZiAoICFxdWVyeUVsZW1lbnQgKSB7XG4gICAgaWYgKCBjb25zb2xlICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ0JhZCBlbGVtZW50IGZvciAnICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lc3BhY2UgK1xuICAgICAgICAnOiAnICsgKCBxdWVyeUVsZW1lbnQgfHwgZWxlbWVudCApICk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmVsZW1lbnQgPSBxdWVyeUVsZW1lbnQ7XG4gIC8vIGFkZCBqUXVlcnlcbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gIH1cblxuICAvLyBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmV4dGVuZCgge30sIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHMgKTtcbiAgdGhpcy5vcHRpb24oIG9wdGlvbnMgKTtcblxuICAvLyBhZGQgaWQgZm9yIE91dGxheWVyLmdldEZyb21FbGVtZW50XG4gIHZhciBpZCA9ICsrR1VJRDtcbiAgdGhpcy5lbGVtZW50Lm91dGxheWVyR1VJRCA9IGlkOyAvLyBleHBhbmRvXG4gIGluc3RhbmNlc1sgaWQgXSA9IHRoaXM7IC8vIGFzc29jaWF0ZSB2aWEgaWRcblxuICAvLyBraWNrIGl0IG9mZlxuICB0aGlzLl9jcmVhdGUoKTtcblxuICB2YXIgaXNJbml0TGF5b3V0ID0gdGhpcy5fZ2V0T3B0aW9uKCdpbml0TGF5b3V0Jyk7XG4gIGlmICggaXNJbml0TGF5b3V0ICkge1xuICAgIHRoaXMubGF5b3V0KCk7XG4gIH1cbn1cblxuLy8gc2V0dGluZ3MgYXJlIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuT3V0bGF5ZXIubmFtZXNwYWNlID0gJ291dGxheWVyJztcbk91dGxheWVyLkl0ZW0gPSBJdGVtO1xuXG4vLyBkZWZhdWx0IG9wdGlvbnNcbk91dGxheWVyLmRlZmF1bHRzID0ge1xuICBjb250YWluZXJTdHlsZToge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gIH0sXG4gIGluaXRMYXlvdXQ6IHRydWUsXG4gIG9yaWdpbkxlZnQ6IHRydWUsXG4gIG9yaWdpblRvcDogdHJ1ZSxcbiAgcmVzaXplOiB0cnVlLFxuICByZXNpemVDb250YWluZXI6IHRydWUsXG4gIC8vIGl0ZW0gb3B0aW9uc1xuICB0cmFuc2l0aW9uRHVyYXRpb246ICcwLjRzJyxcbiAgaGlkZGVuU3R5bGU6IHtcbiAgICBvcGFjaXR5OiAwLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDAuMDAxKSdcbiAgfSxcbiAgdmlzaWJsZVN0eWxlOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2Zvcm06ICdzY2FsZSgxKSdcbiAgfVxufTtcblxudmFyIHByb3RvID0gT3V0bGF5ZXIucHJvdG90eXBlO1xuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnV0aWxzLmV4dGVuZCggcHJvdG8sIEV2RW1pdHRlci5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBzZXQgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xucHJvdG8ub3B0aW9uID0gZnVuY3Rpb24oIG9wdHMgKSB7XG4gIHV0aWxzLmV4dGVuZCggdGhpcy5vcHRpb25zLCBvcHRzICk7XG59O1xuXG4vKipcbiAqIGdldCBiYWNrd2FyZHMgY29tcGF0aWJsZSBvcHRpb24gdmFsdWUsIGNoZWNrIG9sZCBuYW1lXG4gKi9cbnByb3RvLl9nZXRPcHRpb24gPSBmdW5jdGlvbiggb3B0aW9uICkge1xuICB2YXIgb2xkT3B0aW9uID0gdGhpcy5jb25zdHJ1Y3Rvci5jb21wYXRPcHRpb25zWyBvcHRpb24gXTtcbiAgcmV0dXJuIG9sZE9wdGlvbiAmJiB0aGlzLm9wdGlvbnNbIG9sZE9wdGlvbiBdICE9PSB1bmRlZmluZWQgP1xuICAgIHRoaXMub3B0aW9uc1sgb2xkT3B0aW9uIF0gOiB0aGlzLm9wdGlvbnNbIG9wdGlvbiBdO1xufTtcblxuT3V0bGF5ZXIuY29tcGF0T3B0aW9ucyA9IHtcbiAgLy8gY3VycmVudE5hbWU6IG9sZE5hbWVcbiAgaW5pdExheW91dDogJ2lzSW5pdExheW91dCcsXG4gIGhvcml6b250YWw6ICdpc0hvcml6b250YWwnLFxuICBsYXlvdXRJbnN0YW50OiAnaXNMYXlvdXRJbnN0YW50JyxcbiAgb3JpZ2luTGVmdDogJ2lzT3JpZ2luTGVmdCcsXG4gIG9yaWdpblRvcDogJ2lzT3JpZ2luVG9wJyxcbiAgcmVzaXplOiAnaXNSZXNpemVCb3VuZCcsXG4gIHJlc2l6ZUNvbnRhaW5lcjogJ2lzUmVzaXppbmdDb250YWluZXInXG59O1xuXG5wcm90by5fY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIGdldCBpdGVtcyBmcm9tIGNoaWxkcmVuXG4gIHRoaXMucmVsb2FkSXRlbXMoKTtcbiAgLy8gZWxlbWVudHMgdGhhdCBhZmZlY3QgbGF5b3V0LCBidXQgYXJlIG5vdCBsYWlkIG91dFxuICB0aGlzLnN0YW1wcyA9IFtdO1xuICB0aGlzLnN0YW1wKCB0aGlzLm9wdGlvbnMuc3RhbXAgKTtcbiAgLy8gc2V0IGNvbnRhaW5lciBzdHlsZVxuICB1dGlscy5leHRlbmQoIHRoaXMuZWxlbWVudC5zdHlsZSwgdGhpcy5vcHRpb25zLmNvbnRhaW5lclN0eWxlICk7XG5cbiAgLy8gYmluZCByZXNpemUgbWV0aG9kXG4gIHZhciBjYW5CaW5kUmVzaXplID0gdGhpcy5fZ2V0T3B0aW9uKCdyZXNpemUnKTtcbiAgaWYgKCBjYW5CaW5kUmVzaXplICkge1xuICAgIHRoaXMuYmluZFJlc2l6ZSgpO1xuICB9XG59O1xuXG4vLyBnb2VzIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFnYWluIGFuZCBnZXRzIGJyaWNrcyBpbiBwcm9wZXIgb3JkZXJcbnByb3RvLnJlbG9hZEl0ZW1zID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICB0aGlzLml0ZW1zID0gdGhpcy5faXRlbWl6ZSggdGhpcy5lbGVtZW50LmNoaWxkcmVuICk7XG59O1xuXG5cbi8qKlxuICogdHVybiBlbGVtZW50cyBpbnRvIE91dGxheWVyLkl0ZW1zIHRvIGJlIHVzZWQgaW4gbGF5b3V0XG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIGNvbGxlY3Rpb24gb2YgbmV3IE91dGxheWVyIEl0ZW1zXG4gKi9cbnByb3RvLl9pdGVtaXplID0gZnVuY3Rpb24oIGVsZW1zICkge1xuXG4gIHZhciBpdGVtRWxlbXMgPSB0aGlzLl9maWx0ZXJGaW5kSXRlbUVsZW1lbnRzKCBlbGVtcyApO1xuICB2YXIgSXRlbSA9IHRoaXMuY29uc3RydWN0b3IuSXRlbTtcblxuICAvLyBjcmVhdGUgbmV3IE91dGxheWVyIEl0ZW1zIGZvciBjb2xsZWN0aW9uXG4gIHZhciBpdGVtcyA9IFtdO1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgaXRlbUVsZW1zLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBlbGVtID0gaXRlbUVsZW1zW2ldO1xuICAgIHZhciBpdGVtID0gbmV3IEl0ZW0oIGVsZW0sIHRoaXMgKTtcbiAgICBpdGVtcy5wdXNoKCBpdGVtICk7XG4gIH1cblxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIGdldCBpdGVtIGVsZW1lbnRzIHRvIGJlIHVzZWQgaW4gbGF5b3V0XG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEhUTUxFbGVtZW50fSBlbGVtc1xuICogQHJldHVybnMge0FycmF5fSBpdGVtcyAtIGl0ZW0gZWxlbWVudHNcbiAqL1xucHJvdG8uX2ZpbHRlckZpbmRJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHJldHVybiB1dGlscy5maWx0ZXJGaW5kRWxlbWVudHMoIGVsZW1zLCB0aGlzLm9wdGlvbnMuaXRlbVNlbGVjdG9yICk7XG59O1xuXG4vKipcbiAqIGdldHRlciBtZXRob2QgZm9yIGdldHRpbmcgaXRlbSBlbGVtZW50c1xuICogQHJldHVybnMge0FycmF5fSBlbGVtcyAtIGNvbGxlY3Rpb24gb2YgaXRlbSBlbGVtZW50c1xuICovXG5wcm90by5nZXRJdGVtRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICByZXR1cm4gaXRlbS5lbGVtZW50O1xuICB9KTtcbn07XG5cbi8vIC0tLS0tIGluaXQgJiBsYXlvdXQgLS0tLS0gLy9cblxuLyoqXG4gKiBsYXlzIG91dCBhbGwgaXRlbXNcbiAqL1xucHJvdG8ubGF5b3V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3Jlc2V0TGF5b3V0KCk7XG4gIHRoaXMuX21hbmFnZVN0YW1wcygpO1xuXG4gIC8vIGRvbid0IGFuaW1hdGUgZmlyc3QgbGF5b3V0XG4gIHZhciBsYXlvdXRJbnN0YW50ID0gdGhpcy5fZ2V0T3B0aW9uKCdsYXlvdXRJbnN0YW50Jyk7XG4gIHZhciBpc0luc3RhbnQgPSBsYXlvdXRJbnN0YW50ICE9PSB1bmRlZmluZWQgP1xuICAgIGxheW91dEluc3RhbnQgOiAhdGhpcy5faXNMYXlvdXRJbml0ZWQ7XG4gIHRoaXMubGF5b3V0SXRlbXMoIHRoaXMuaXRlbXMsIGlzSW5zdGFudCApO1xuXG4gIC8vIGZsYWcgZm9yIGluaXRhbGl6ZWRcbiAgdGhpcy5faXNMYXlvdXRJbml0ZWQgPSB0cnVlO1xufTtcblxuLy8gX2luaXQgaXMgYWxpYXMgZm9yIGxheW91dFxucHJvdG8uX2luaXQgPSBwcm90by5sYXlvdXQ7XG5cbi8qKlxuICogbG9naWMgYmVmb3JlIGFueSBuZXcgbGF5b3V0XG4gKi9cbnByb3RvLl9yZXNldExheW91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdldFNpemUoKTtcbn07XG5cblxucHJvdG8uZ2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbn07XG5cbi8qKlxuICogZ2V0IG1lYXN1cmVtZW50IGZyb20gb3B0aW9uLCBmb3IgY29sdW1uV2lkdGgsIHJvd0hlaWdodCwgZ3V0dGVyXG4gKiBpZiBvcHRpb24gaXMgU3RyaW5nIC0+IGdldCBlbGVtZW50IGZyb20gc2VsZWN0b3Igc3RyaW5nLCAmIGdldCBzaXplIG9mIGVsZW1lbnRcbiAqIGlmIG9wdGlvbiBpcyBFbGVtZW50IC0+IGdldCBzaXplIG9mIGVsZW1lbnRcbiAqIGVsc2UgdXNlIG9wdGlvbiBhcyBhIG51bWJlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZWFzdXJlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSB3aWR0aCBvciBoZWlnaHRcbiAqIEBwcml2YXRlXG4gKi9cbnByb3RvLl9nZXRNZWFzdXJlbWVudCA9IGZ1bmN0aW9uKCBtZWFzdXJlbWVudCwgc2l6ZSApIHtcbiAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uc1sgbWVhc3VyZW1lbnQgXTtcbiAgdmFyIGVsZW07XG4gIGlmICggIW9wdGlvbiApIHtcbiAgICAvLyBkZWZhdWx0IHRvIDBcbiAgICB0aGlzWyBtZWFzdXJlbWVudCBdID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2Ugb3B0aW9uIGFzIGFuIGVsZW1lbnRcbiAgICBpZiAoIHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgKSB7XG4gICAgICBlbGVtID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoIG9wdGlvbiApO1xuICAgIH0gZWxzZSBpZiAoIG9wdGlvbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICkge1xuICAgICAgZWxlbSA9IG9wdGlvbjtcbiAgICB9XG4gICAgLy8gdXNlIHNpemUgb2YgZWxlbWVudCwgaWYgZWxlbWVudFxuICAgIHRoaXNbIG1lYXN1cmVtZW50IF0gPSBlbGVtID8gZ2V0U2l6ZSggZWxlbSApWyBzaXplIF0gOiBvcHRpb247XG4gIH1cbn07XG5cbi8qKlxuICogbGF5b3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtIGVsZW1lbnRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5wcm90by5sYXlvdXRJdGVtcyA9IGZ1bmN0aW9uKCBpdGVtcywgaXNJbnN0YW50ICkge1xuICBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zRm9yTGF5b3V0KCBpdGVtcyApO1xuXG4gIHRoaXMuX2xheW91dEl0ZW1zKCBpdGVtcywgaXNJbnN0YW50ICk7XG5cbiAgdGhpcy5fcG9zdExheW91dCgpO1xufTtcblxuLyoqXG4gKiBnZXQgdGhlIGl0ZW1zIHRvIGJlIGxhaWQgb3V0XG4gKiB5b3UgbWF5IHdhbnQgdG8gc2tpcCBvdmVyIHNvbWUgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zXG4gKi9cbnByb3RvLl9nZXRJdGVtc0ZvckxheW91dCA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgcmV0dXJuIGl0ZW1zLmZpbHRlciggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgcmV0dXJuICFpdGVtLmlzSWdub3JlZDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGxheW91dCBpdGVtc1xuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbnN0YW50XG4gKi9cbnByb3RvLl9sYXlvdXRJdGVtcyA9IGZ1bmN0aW9uKCBpdGVtcywgaXNJbnN0YW50ICkge1xuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAnbGF5b3V0JywgaXRlbXMgKTtcblxuICBpZiAoICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoICkge1xuICAgIC8vIG5vIGl0ZW1zLCBlbWl0IGV2ZW50IHdpdGggZW1wdHkgYXJyYXlcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcXVldWUgPSBbXTtcblxuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICAvLyBnZXQgeC95IG9iamVjdCBmcm9tIG1ldGhvZFxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiggaXRlbSApO1xuICAgIC8vIGVucXVldWVcbiAgICBwb3NpdGlvbi5pdGVtID0gaXRlbTtcbiAgICBwb3NpdGlvbi5pc0luc3RhbnQgPSBpc0luc3RhbnQgfHwgaXRlbS5pc0xheW91dEluc3RhbnQ7XG4gICAgcXVldWUucHVzaCggcG9zaXRpb24gKTtcbiAgfSwgdGhpcyApO1xuXG4gIHRoaXMuX3Byb2Nlc3NMYXlvdXRRdWV1ZSggcXVldWUgKTtcbn07XG5cbi8qKlxuICogZ2V0IGl0ZW0gbGF5b3V0IHBvc2l0aW9uXG4gKiBAcGFyYW0ge091dGxheWVyLkl0ZW19IGl0ZW1cbiAqIEByZXR1cm5zIHtPYmplY3R9IHggYW5kIHkgcG9zaXRpb25cbiAqL1xucHJvdG8uX2dldEl0ZW1MYXlvdXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCAvKiBpdGVtICovICkge1xuICByZXR1cm4ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xufTtcblxuLyoqXG4gKiBpdGVyYXRlIG92ZXIgYXJyYXkgYW5kIHBvc2l0aW9uIGVhY2ggaXRlbVxuICogUmVhc29uIGJlaW5nIC0gc2VwYXJhdGluZyB0aGlzIGxvZ2ljIHByZXZlbnRzICdsYXlvdXQgaW52YWxpZGF0aW9uJ1xuICogdGh4IEBwYXVsX2lyaXNoXG4gKiBAcGFyYW0ge0FycmF5fSBxdWV1ZVxuICovXG5wcm90by5fcHJvY2Vzc0xheW91dFF1ZXVlID0gZnVuY3Rpb24oIHF1ZXVlICkge1xuICB0aGlzLnVwZGF0ZVN0YWdnZXIoKTtcbiAgcXVldWUuZm9yRWFjaCggZnVuY3Rpb24oIG9iaiwgaSApIHtcbiAgICB0aGlzLl9wb3NpdGlvbkl0ZW0oIG9iai5pdGVtLCBvYmoueCwgb2JqLnksIG9iai5pc0luc3RhbnQsIGkgKTtcbiAgfSwgdGhpcyApO1xufTtcblxuLy8gc2V0IHN0YWdnZXIgZnJvbSBvcHRpb24gaW4gbWlsbGlzZWNvbmRzIG51bWJlclxucHJvdG8udXBkYXRlU3RhZ2dlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhZ2dlciA9IHRoaXMub3B0aW9ucy5zdGFnZ2VyO1xuICBpZiAoIHN0YWdnZXIgPT09IG51bGwgfHwgc3RhZ2dlciA9PT0gdW5kZWZpbmVkICkge1xuICAgIHRoaXMuc3RhZ2dlciA9IDA7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuc3RhZ2dlciA9IGdldE1pbGxpc2Vjb25kcyggc3RhZ2dlciApO1xuICByZXR1cm4gdGhpcy5zdGFnZ2VyO1xufTtcblxuLyoqXG4gKiBTZXRzIHBvc2l0aW9uIG9mIGl0ZW0gaW4gRE9NXG4gKiBAcGFyYW0ge091dGxheWVyLkl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gaG9yaXpvbnRhbCBwb3NpdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHkgLSB2ZXJ0aWNhbCBwb3NpdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBpc0luc3RhbnQgLSBkaXNhYmxlcyB0cmFuc2l0aW9uc1xuICovXG5wcm90by5fcG9zaXRpb25JdGVtID0gZnVuY3Rpb24oIGl0ZW0sIHgsIHksIGlzSW5zdGFudCwgaSApIHtcbiAgaWYgKCBpc0luc3RhbnQgKSB7XG4gICAgLy8gaWYgbm90IHRyYW5zaXRpb24sIGp1c3Qgc2V0IENTU1xuICAgIGl0ZW0uZ29UbyggeCwgeSApO1xuICB9IGVsc2Uge1xuICAgIGl0ZW0uc3RhZ2dlciggaSAqIHRoaXMuc3RhZ2dlciApO1xuICAgIGl0ZW0ubW92ZVRvKCB4LCB5ICk7XG4gIH1cbn07XG5cbi8qKlxuICogQW55IGxvZ2ljIHlvdSB3YW50IHRvIGRvIGFmdGVyIGVhY2ggbGF5b3V0LFxuICogaS5lLiBzaXplIHRoZSBjb250YWluZXJcbiAqL1xucHJvdG8uX3Bvc3RMYXlvdXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZXNpemVDb250YWluZXIoKTtcbn07XG5cbnByb3RvLnJlc2l6ZUNvbnRhaW5lciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXNSZXNpemluZ0NvbnRhaW5lciA9IHRoaXMuX2dldE9wdGlvbigncmVzaXplQ29udGFpbmVyJyk7XG4gIGlmICggIWlzUmVzaXppbmdDb250YWluZXIgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBzaXplID0gdGhpcy5fZ2V0Q29udGFpbmVyU2l6ZSgpO1xuICBpZiAoIHNpemUgKSB7XG4gICAgdGhpcy5fc2V0Q29udGFpbmVyTWVhc3VyZSggc2l6ZS53aWR0aCwgdHJ1ZSApO1xuICAgIHRoaXMuX3NldENvbnRhaW5lck1lYXN1cmUoIHNpemUuaGVpZ2h0LCBmYWxzZSApO1xuICB9XG59O1xuXG4vKipcbiAqIFNldHMgd2lkdGggb3IgaGVpZ2h0IG9mIGNvbnRhaW5lciBpZiByZXR1cm5lZFxuICogQHJldHVybnMge09iamVjdH0gc2l6ZVxuICogICBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAqICAgQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICovXG5wcm90by5fZ2V0Q29udGFpbmVyU2l6ZSA9IG5vb3A7XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1lYXN1cmUgLSBzaXplIG9mIHdpZHRoIG9yIGhlaWdodFxuICogQHBhcmFtIHtCb29sZWFufSBpc1dpZHRoXG4gKi9cbnByb3RvLl9zZXRDb250YWluZXJNZWFzdXJlID0gZnVuY3Rpb24oIG1lYXN1cmUsIGlzV2lkdGggKSB7XG4gIGlmICggbWVhc3VyZSA9PT0gdW5kZWZpbmVkICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVtU2l6ZSA9IHRoaXMuc2l6ZTtcbiAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB3aWR0aCBpZiBib3JkZXIgYm94XG4gIGlmICggZWxlbVNpemUuaXNCb3JkZXJCb3ggKSB7XG4gICAgbWVhc3VyZSArPSBpc1dpZHRoID8gZWxlbVNpemUucGFkZGluZ0xlZnQgKyBlbGVtU2l6ZS5wYWRkaW5nUmlnaHQgK1xuICAgICAgZWxlbVNpemUuYm9yZGVyTGVmdFdpZHRoICsgZWxlbVNpemUuYm9yZGVyUmlnaHRXaWR0aCA6XG4gICAgICBlbGVtU2l6ZS5wYWRkaW5nQm90dG9tICsgZWxlbVNpemUucGFkZGluZ1RvcCArXG4gICAgICBlbGVtU2l6ZS5ib3JkZXJUb3BXaWR0aCArIGVsZW1TaXplLmJvcmRlckJvdHRvbVdpZHRoO1xuICB9XG5cbiAgbWVhc3VyZSA9IE1hdGgubWF4KCBtZWFzdXJlLCAwICk7XG4gIHRoaXMuZWxlbWVudC5zdHlsZVsgaXNXaWR0aCA/ICd3aWR0aCcgOiAnaGVpZ2h0JyBdID0gbWVhc3VyZSArICdweCc7XG59O1xuXG4vKipcbiAqIGVtaXQgZXZlbnRDb21wbGV0ZSBvbiBhIGNvbGxlY3Rpb24gb2YgaXRlbXMgZXZlbnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIE91dGxheWVyLkl0ZW1zXG4gKi9cbnByb3RvLl9lbWl0Q29tcGxldGVPbkl0ZW1zID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgaXRlbXMgKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgX3RoaXMuZGlzcGF0Y2hFdmVudCggZXZlbnROYW1lICsgJ0NvbXBsZXRlJywgbnVsbCwgWyBpdGVtcyBdICk7XG4gIH1cblxuICB2YXIgY291bnQgPSBpdGVtcy5sZW5ndGg7XG4gIGlmICggIWl0ZW1zIHx8ICFjb3VudCApIHtcbiAgICBvbkNvbXBsZXRlKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRvbmVDb3VudCA9IDA7XG4gIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgZG9uZUNvdW50Kys7XG4gICAgaWYgKCBkb25lQ291bnQgPT0gY291bnQgKSB7XG4gICAgICBvbkNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYmluZCBjYWxsYmFja1xuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICBpdGVtLm9uY2UoIGV2ZW50TmFtZSwgdGljayApO1xuICB9KTtcbn07XG5cbi8qKlxuICogZW1pdHMgZXZlbnRzIHZpYSBFdkVtaXR0ZXIgYW5kIGpRdWVyeSBldmVudHNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gbmFtZSBvZiBldmVudFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBvcmlnaW5hbCBldmVudFxuICogQHBhcmFtIHtBcnJheX0gYXJncyAtIGV4dHJhIGFyZ3VtZW50c1xuICovXG5wcm90by5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBhcmdzICkge1xuICAvLyBhZGQgb3JpZ2luYWwgZXZlbnQgdG8gYXJndW1lbnRzXG4gIHZhciBlbWl0QXJncyA9IGV2ZW50ID8gWyBldmVudCBdLmNvbmNhdCggYXJncyApIDogYXJncztcbiAgdGhpcy5lbWl0RXZlbnQoIHR5cGUsIGVtaXRBcmdzICk7XG5cbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgLy8gc2V0IHRoaXMuJGVsZW1lbnRcbiAgICB0aGlzLiRlbGVtZW50ID0gdGhpcy4kZWxlbWVudCB8fCBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xuICAgIGlmICggZXZlbnQgKSB7XG4gICAgICAvLyBjcmVhdGUgalF1ZXJ5IGV2ZW50XG4gICAgICB2YXIgJGV2ZW50ID0galF1ZXJ5LkV2ZW50KCBldmVudCApO1xuICAgICAgJGV2ZW50LnR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCAkZXZlbnQsIGFyZ3MgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCB0cmlnZ2VyIHdpdGggdHlwZSBpZiBubyBldmVudCBhdmFpbGFibGVcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggdHlwZSwgYXJncyApO1xuICAgIH1cbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaWdub3JlICYgc3RhbXBzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cblxuLyoqXG4gKiBrZWVwIGl0ZW0gaW4gY29sbGVjdGlvbiwgYnV0IGRvIG5vdCBsYXkgaXQgb3V0XG4gKiBpZ25vcmVkIGl0ZW1zIGRvIG5vdCBnZXQgc2tpcHBlZCBpbiBsYXlvdXRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICovXG5wcm90by5pZ25vcmUgPSBmdW5jdGlvbiggZWxlbSApIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oIGVsZW0gKTtcbiAgaWYgKCBpdGVtICkge1xuICAgIGl0ZW0uaXNJZ25vcmVkID0gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiByZXR1cm4gaXRlbSB0byBsYXlvdXQgY29sbGVjdGlvblxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKi9cbnByb3RvLnVuaWdub3JlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKCBlbGVtICk7XG4gIGlmICggaXRlbSApIHtcbiAgICBkZWxldGUgaXRlbS5pc0lnbm9yZWQ7XG4gIH1cbn07XG5cbi8qKlxuICogYWRkcyBlbGVtZW50cyB0byBzdGFtcHNcbiAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBFbGVtZW50LCBvciBTdHJpbmd9IGVsZW1zXG4gKi9cbnByb3RvLnN0YW1wID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBlbGVtcyA9IHRoaXMuX2ZpbmQoIGVsZW1zICk7XG4gIGlmICggIWVsZW1zICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc3RhbXBzID0gdGhpcy5zdGFtcHMuY29uY2F0KCBlbGVtcyApO1xuICAvLyBpZ25vcmVcbiAgZWxlbXMuZm9yRWFjaCggdGhpcy5pZ25vcmUsIHRoaXMgKTtcbn07XG5cbi8qKlxuICogcmVtb3ZlcyBlbGVtZW50cyB0byBzdGFtcHNcbiAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by51bnN0YW1wID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBlbGVtcyA9IHRoaXMuX2ZpbmQoIGVsZW1zICk7XG4gIGlmICggIWVsZW1zICl7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgLy8gZmlsdGVyIG91dCByZW1vdmVkIHN0YW1wIGVsZW1lbnRzXG4gICAgdXRpbHMucmVtb3ZlRnJvbSggdGhpcy5zdGFtcHMsIGVsZW0gKTtcbiAgICB0aGlzLnVuaWdub3JlKCBlbGVtICk7XG4gIH0sIHRoaXMgKTtcbn07XG5cbi8qKlxuICogZmluZHMgY2hpbGQgZWxlbWVudHNcbiAqIEBwYXJhbSB7Tm9kZUxpc3QsIEFycmF5LCBFbGVtZW50LCBvciBTdHJpbmd9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGVsZW1zXG4gKi9cbnByb3RvLl9maW5kID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICBpZiAoICFlbGVtcyApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gaWYgc3RyaW5nLCB1c2UgYXJndW1lbnQgYXMgc2VsZWN0b3Igc3RyaW5nXG4gIGlmICggdHlwZW9mIGVsZW1zID09ICdzdHJpbmcnICkge1xuICAgIGVsZW1zID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIGVsZW1zICk7XG4gIH1cbiAgZWxlbXMgPSB1dGlscy5tYWtlQXJyYXkoIGVsZW1zICk7XG4gIHJldHVybiBlbGVtcztcbn07XG5cbnByb3RvLl9tYW5hZ2VTdGFtcHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5zdGFtcHMgfHwgIXRoaXMuc3RhbXBzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9nZXRCb3VuZGluZ1JlY3QoKTtcblxuICB0aGlzLnN0YW1wcy5mb3JFYWNoKCB0aGlzLl9tYW5hZ2VTdGFtcCwgdGhpcyApO1xufTtcblxuLy8gdXBkYXRlIGJvdW5kaW5nTGVmdCAvIFRvcFxucHJvdG8uX2dldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uKCkge1xuICAvLyBnZXQgYm91bmRpbmcgcmVjdCBmb3IgY29udGFpbmVyIGVsZW1lbnRcbiAgdmFyIGJvdW5kaW5nUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gIHRoaXMuX2JvdW5kaW5nUmVjdCA9IHtcbiAgICBsZWZ0OiBib3VuZGluZ1JlY3QubGVmdCArIHNpemUucGFkZGluZ0xlZnQgKyBzaXplLmJvcmRlckxlZnRXaWR0aCxcbiAgICB0b3A6IGJvdW5kaW5nUmVjdC50b3AgKyBzaXplLnBhZGRpbmdUb3AgKyBzaXplLmJvcmRlclRvcFdpZHRoLFxuICAgIHJpZ2h0OiBib3VuZGluZ1JlY3QucmlnaHQgLSAoIHNpemUucGFkZGluZ1JpZ2h0ICsgc2l6ZS5ib3JkZXJSaWdodFdpZHRoICksXG4gICAgYm90dG9tOiBib3VuZGluZ1JlY3QuYm90dG9tIC0gKCBzaXplLnBhZGRpbmdCb3R0b20gKyBzaXplLmJvcmRlckJvdHRvbVdpZHRoIClcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBzdGFtcFxuKiovXG5wcm90by5fbWFuYWdlU3RhbXAgPSBub29wO1xuXG4vKipcbiAqIGdldCB4L3kgcG9zaXRpb24gb2YgZWxlbWVudCByZWxhdGl2ZSB0byBjb250YWluZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvZmZzZXQgLSBoYXMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gKi9cbnByb3RvLl9nZXRFbGVtZW50T2Zmc2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHZhciBib3VuZGluZ1JlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgdGhpc1JlY3QgPSB0aGlzLl9ib3VuZGluZ1JlY3Q7XG4gIHZhciBzaXplID0gZ2V0U2l6ZSggZWxlbSApO1xuICB2YXIgb2Zmc2V0ID0ge1xuICAgIGxlZnQ6IGJvdW5kaW5nUmVjdC5sZWZ0IC0gdGhpc1JlY3QubGVmdCAtIHNpemUubWFyZ2luTGVmdCxcbiAgICB0b3A6IGJvdW5kaW5nUmVjdC50b3AgLSB0aGlzUmVjdC50b3AgLSBzaXplLm1hcmdpblRvcCxcbiAgICByaWdodDogdGhpc1JlY3QucmlnaHQgLSBib3VuZGluZ1JlY3QucmlnaHQgLSBzaXplLm1hcmdpblJpZ2h0LFxuICAgIGJvdHRvbTogdGhpc1JlY3QuYm90dG9tIC0gYm91bmRpbmdSZWN0LmJvdHRvbSAtIHNpemUubWFyZ2luQm90dG9tXG4gIH07XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSByZXNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZW5hYmxlIGV2ZW50IGhhbmRsZXJzIGZvciBsaXN0ZW5lcnNcbi8vIGkuZS4gcmVzaXplIC0+IG9ucmVzaXplXG5wcm90by5oYW5kbGVFdmVudCA9IHV0aWxzLmhhbmRsZUV2ZW50O1xuXG4vKipcbiAqIEJpbmQgbGF5b3V0IHRvIHdpbmRvdyByZXNpemluZ1xuICovXG5wcm90by5iaW5kUmVzaXplID0gZnVuY3Rpb24oKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncmVzaXplJywgdGhpcyApO1xuICB0aGlzLmlzUmVzaXplQm91bmQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgbGF5b3V0IHRvIHdpbmRvdyByZXNpemluZ1xuICovXG5wcm90by51bmJpbmRSZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCB0aGlzICk7XG4gIHRoaXMuaXNSZXNpemVCb3VuZCA9IGZhbHNlO1xufTtcblxucHJvdG8ub25yZXNpemUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZXNpemUoKTtcbn07XG5cbnV0aWxzLmRlYm91bmNlTWV0aG9kKCBPdXRsYXllciwgJ29ucmVzaXplJywgMTAwICk7XG5cbnByb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBkb24ndCB0cmlnZ2VyIGlmIHNpemUgZGlkIG5vdCBjaGFuZ2VcbiAgLy8gb3IgaWYgcmVzaXplIHdhcyB1bmJvdW5kLiBTZWUgIzlcbiAgaWYgKCAhdGhpcy5pc1Jlc2l6ZUJvdW5kIHx8ICF0aGlzLm5lZWRzUmVzaXplTGF5b3V0KCkgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5sYXlvdXQoKTtcbn07XG5cbi8qKlxuICogY2hlY2sgaWYgbGF5b3V0IGlzIG5lZWRlZCBwb3N0IGxheW91dFxuICogQHJldHVybnMgQm9vbGVhblxuICovXG5wcm90by5uZWVkc1Jlc2l6ZUxheW91dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xuICAvLyBjaGVjayB0aGF0IHRoaXMuc2l6ZSBhbmQgc2l6ZSBhcmUgdGhlcmVcbiAgLy8gSUU4IHRyaWdnZXJzIHJlc2l6ZSBvbiBib2R5IHNpemUgY2hhbmdlLCBzbyB0aGV5IG1pZ2h0IG5vdCBiZVxuICB2YXIgaGFzU2l6ZXMgPSB0aGlzLnNpemUgJiYgc2l6ZTtcbiAgcmV0dXJuIGhhc1NpemVzICYmIHNpemUuaW5uZXJXaWR0aCAhPT0gdGhpcy5zaXplLmlubmVyV2lkdGg7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogYWRkIGl0ZW1zIHRvIE91dGxheWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gT3V0bGF5ZXIuSXRlbXNcbioqL1xucHJvdG8uYWRkSXRlbXMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1pemUoIGVsZW1zICk7XG4gIC8vIGFkZCBpdGVtcyB0byBjb2xsZWN0aW9uXG4gIGlmICggaXRlbXMubGVuZ3RoICkge1xuICAgIHRoaXMuaXRlbXMgPSB0aGlzLml0ZW1zLmNvbmNhdCggaXRlbXMgKTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59O1xuXG4vKipcbiAqIExheW91dCBuZXdseS1hcHBlbmRlZCBpdGVtIGVsZW1lbnRzXG4gKiBAcGFyYW0ge0FycmF5IG9yIE5vZGVMaXN0IG9yIEVsZW1lbnR9IGVsZW1zXG4gKi9cbnByb3RvLmFwcGVuZGVkID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgaXRlbXMgPSB0aGlzLmFkZEl0ZW1zKCBlbGVtcyApO1xuICBpZiAoICFpdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGxheW91dCBhbmQgcmV2ZWFsIGp1c3QgdGhlIG5ldyBpdGVtc1xuICB0aGlzLmxheW91dEl0ZW1zKCBpdGVtcywgdHJ1ZSApO1xuICB0aGlzLnJldmVhbCggaXRlbXMgKTtcbn07XG5cbi8qKlxuICogTGF5b3V0IHByZXBlbmRlZCBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheSBvciBOb2RlTGlzdCBvciBFbGVtZW50fSBlbGVtc1xuICovXG5wcm90by5wcmVwZW5kZWQgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuX2l0ZW1pemUoIGVsZW1zICk7XG4gIGlmICggIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gYWRkIGl0ZW1zIHRvIGJlZ2lubmluZyBvZiBjb2xsZWN0aW9uXG4gIHZhciBwcmV2aW91c0l0ZW1zID0gdGhpcy5pdGVtcy5zbGljZSgwKTtcbiAgdGhpcy5pdGVtcyA9IGl0ZW1zLmNvbmNhdCggcHJldmlvdXNJdGVtcyApO1xuICAvLyBzdGFydCBuZXcgbGF5b3V0XG4gIHRoaXMuX3Jlc2V0TGF5b3V0KCk7XG4gIHRoaXMuX21hbmFnZVN0YW1wcygpO1xuICAvLyBsYXlvdXQgbmV3IHN0dWZmIHdpdGhvdXQgdHJhbnNpdGlvblxuICB0aGlzLmxheW91dEl0ZW1zKCBpdGVtcywgdHJ1ZSApO1xuICB0aGlzLnJldmVhbCggaXRlbXMgKTtcbiAgLy8gbGF5b3V0IHByZXZpb3VzIGl0ZW1zXG4gIHRoaXMubGF5b3V0SXRlbXMoIHByZXZpb3VzSXRlbXMgKTtcbn07XG5cbi8qKlxuICogcmV2ZWFsIGEgY29sbGVjdGlvbiBvZiBpdGVtc1xuICogQHBhcmFtIHtBcnJheSBvZiBPdXRsYXllci5JdGVtc30gaXRlbXNcbiAqL1xucHJvdG8ucmV2ZWFsID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuICB0aGlzLl9lbWl0Q29tcGxldGVPbkl0ZW1zKCAncmV2ZWFsJywgaXRlbXMgKTtcbiAgaWYgKCAhaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHN0YWdnZXIgPSB0aGlzLnVwZGF0ZVN0YWdnZXIoKTtcbiAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG4gICAgaXRlbS5zdGFnZ2VyKCBpICogc3RhZ2dlciApO1xuICAgIGl0ZW0ucmV2ZWFsKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBoaWRlIGEgY29sbGVjdGlvbiBvZiBpdGVtc1xuICogQHBhcmFtIHtBcnJheSBvZiBPdXRsYXllci5JdGVtc30gaXRlbXNcbiAqL1xucHJvdG8uaGlkZSA9IGZ1bmN0aW9uKCBpdGVtcyApIHtcbiAgdGhpcy5fZW1pdENvbXBsZXRlT25JdGVtcyggJ2hpZGUnLCBpdGVtcyApO1xuICBpZiAoICFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc3RhZ2dlciA9IHRoaXMudXBkYXRlU3RhZ2dlcigpO1xuICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSwgaSApIHtcbiAgICBpdGVtLnN0YWdnZXIoIGkgKiBzdGFnZ2VyICk7XG4gICAgaXRlbS5oaWRlKCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiByZXZlYWwgaXRlbSBlbGVtZW50c1xuICogQHBhcmFtIHtBcnJheX0sIHtFbGVtZW50fSwge05vZGVMaXN0fSBpdGVtc1xuICovXG5wcm90by5yZXZlYWxJdGVtRWxlbWVudHMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMuZ2V0SXRlbXMoIGVsZW1zICk7XG4gIHRoaXMucmV2ZWFsKCBpdGVtcyApO1xufTtcblxuLyoqXG4gKiBoaWRlIGl0ZW0gZWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9LCB7RWxlbWVudH0sIHtOb2RlTGlzdH0gaXRlbXNcbiAqL1xucHJvdG8uaGlkZUl0ZW1FbGVtZW50cyA9IGZ1bmN0aW9uKCBlbGVtcyApIHtcbiAgdmFyIGl0ZW1zID0gdGhpcy5nZXRJdGVtcyggZWxlbXMgKTtcbiAgdGhpcy5oaWRlKCBpdGVtcyApO1xufTtcblxuLyoqXG4gKiBnZXQgT3V0bGF5ZXIuSXRlbSwgZ2l2ZW4gYW4gRWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge091dGxheWVyLkl0ZW19IGl0ZW1cbiAqL1xucHJvdG8uZ2V0SXRlbSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICAvLyBsb29wIHRocm91Z2ggaXRlbXMgdG8gZ2V0IHRoZSBvbmUgdGhhdCBtYXRjaGVzXG4gIGZvciAoIHZhciBpPTA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBpdGVtID0gdGhpcy5pdGVtc1tpXTtcbiAgICBpZiAoIGl0ZW0uZWxlbWVudCA9PSBlbGVtICkge1xuICAgICAgLy8gcmV0dXJuIGl0ZW1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgY29sbGVjdGlvbiBvZiBPdXRsYXllci5JdGVtcywgZ2l2ZW4gRWxlbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGVsZW1zXG4gKiBAcmV0dXJucyB7QXJyYXl9IGl0ZW1zIC0gT3V0bGF5ZXIuSXRlbXNcbiAqL1xucHJvdG8uZ2V0SXRlbXMgPSBmdW5jdGlvbiggZWxlbXMgKSB7XG4gIGVsZW1zID0gdXRpbHMubWFrZUFycmF5KCBlbGVtcyApO1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgZWxlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgdmFyIGl0ZW0gPSB0aGlzLmdldEl0ZW0oIGVsZW0gKTtcbiAgICBpZiAoIGl0ZW0gKSB7XG4gICAgICBpdGVtcy5wdXNoKCBpdGVtICk7XG4gICAgfVxuICB9LCB0aGlzICk7XG5cbiAgcmV0dXJuIGl0ZW1zO1xufTtcblxuLyoqXG4gKiByZW1vdmUgZWxlbWVudChzKSBmcm9tIGluc3RhbmNlIGFuZCBET01cbiAqIEBwYXJhbSB7QXJyYXkgb3IgTm9kZUxpc3Qgb3IgRWxlbWVudH0gZWxlbXNcbiAqL1xucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oIGVsZW1zICkge1xuICB2YXIgcmVtb3ZlSXRlbXMgPSB0aGlzLmdldEl0ZW1zKCBlbGVtcyApO1xuXG4gIHRoaXMuX2VtaXRDb21wbGV0ZU9uSXRlbXMoICdyZW1vdmUnLCByZW1vdmVJdGVtcyApO1xuXG4gIC8vIGJhaWwgaWYgbm8gaXRlbXMgdG8gcmVtb3ZlXG4gIGlmICggIXJlbW92ZUl0ZW1zIHx8ICFyZW1vdmVJdGVtcy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmVtb3ZlSXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG4gICAgaXRlbS5yZW1vdmUoKTtcbiAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGNvbGxlY3Rpb25cbiAgICB1dGlscy5yZW1vdmVGcm9tKCB0aGlzLml0ZW1zLCBpdGVtICk7XG4gIH0sIHRoaXMgKTtcbn07XG5cbi8vIC0tLS0tIGRlc3Ryb3kgLS0tLS0gLy9cblxuLy8gcmVtb3ZlIGFuZCBkaXNhYmxlIE91dGxheWVyIGluc3RhbmNlXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNsZWFuIHVwIGR5bmFtaWMgc3R5bGVzXG4gIHZhciBzdHlsZSA9IHRoaXMuZWxlbWVudC5zdHlsZTtcbiAgc3R5bGUuaGVpZ2h0ID0gJyc7XG4gIHN0eWxlLnBvc2l0aW9uID0gJyc7XG4gIHN0eWxlLndpZHRoID0gJyc7XG4gIC8vIGRlc3Ryb3kgaXRlbXNcbiAgdGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcbiAgICBpdGVtLmRlc3Ryb3koKTtcbiAgfSk7XG5cbiAgdGhpcy51bmJpbmRSZXNpemUoKTtcblxuICB2YXIgaWQgPSB0aGlzLmVsZW1lbnQub3V0bGF5ZXJHVUlEO1xuICBkZWxldGUgaW5zdGFuY2VzWyBpZCBdOyAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIGluc3RhbmNlIGJ5IGlkXG4gIGRlbGV0ZSB0aGlzLmVsZW1lbnQub3V0bGF5ZXJHVUlEO1xuICAvLyByZW1vdmUgZGF0YSBmb3IgalF1ZXJ5XG4gIGlmICggalF1ZXJ5ICkge1xuICAgIGpRdWVyeS5yZW1vdmVEYXRhKCB0aGlzLmVsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IubmFtZXNwYWNlICk7XG4gIH1cblxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGF0YSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGdldCBPdXRsYXllciBpbnN0YW5jZSBmcm9tIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbVxuICogQHJldHVybnMge091dGxheWVyfVxuICovXG5PdXRsYXllci5kYXRhID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIGVsZW0gPSB1dGlscy5nZXRRdWVyeUVsZW1lbnQoIGVsZW0gKTtcbiAgdmFyIGlkID0gZWxlbSAmJiBlbGVtLm91dGxheWVyR1VJRDtcbiAgcmV0dXJuIGlkICYmIGluc3RhbmNlc1sgaWQgXTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gY3JlYXRlIE91dGxheWVyIGNsYXNzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8qKlxuICogY3JlYXRlIGEgbGF5b3V0IGNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKi9cbk91dGxheWVyLmNyZWF0ZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2UsIG9wdGlvbnMgKSB7XG4gIC8vIHN1Yi1jbGFzcyBPdXRsYXllclxuICB2YXIgTGF5b3V0ID0gc3ViY2xhc3MoIE91dGxheWVyICk7XG4gIC8vIGFwcGx5IG5ldyBvcHRpb25zIGFuZCBjb21wYXRPcHRpb25zXG4gIExheW91dC5kZWZhdWx0cyA9IHV0aWxzLmV4dGVuZCgge30sIE91dGxheWVyLmRlZmF1bHRzICk7XG4gIHV0aWxzLmV4dGVuZCggTGF5b3V0LmRlZmF1bHRzLCBvcHRpb25zICk7XG4gIExheW91dC5jb21wYXRPcHRpb25zID0gdXRpbHMuZXh0ZW5kKCB7fSwgT3V0bGF5ZXIuY29tcGF0T3B0aW9ucyAgKTtcblxuICBMYXlvdXQubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIExheW91dC5kYXRhID0gT3V0bGF5ZXIuZGF0YTtcblxuICAvLyBzdWItY2xhc3MgSXRlbVxuICBMYXlvdXQuSXRlbSA9IHN1YmNsYXNzKCBJdGVtICk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGVjbGFyYXRpdmUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICB1dGlscy5odG1sSW5pdCggTGF5b3V0LCBuYW1lc3BhY2UgKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBqUXVlcnkgYnJpZGdlIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgLy8gbWFrZSBpbnRvIGpRdWVyeSBwbHVnaW5cbiAgaWYgKCBqUXVlcnkgJiYgalF1ZXJ5LmJyaWRnZXQgKSB7XG4gICAgalF1ZXJ5LmJyaWRnZXQoIG5hbWVzcGFjZSwgTGF5b3V0ICk7XG4gIH1cblxuICByZXR1cm4gTGF5b3V0O1xufTtcblxuZnVuY3Rpb24gc3ViY2xhc3MoIFBhcmVudCApIHtcbiAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XG4gICAgUGFyZW50LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcbiAgfVxuXG4gIFN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcbiAgU3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViQ2xhc3M7XG5cbiAgcmV0dXJuIFN1YkNsYXNzO1xufVxuXG4vLyAtLS0tLSBoZWxwZXJzIC0tLS0tIC8vXG5cbi8vIGhvdyBtYW55IG1pbGxpc2Vjb25kcyBhcmUgaW4gZWFjaCB1bml0XG52YXIgbXNVbml0cyA9IHtcbiAgbXM6IDEsXG4gIHM6IDEwMDBcbn07XG5cbi8vIG11bmdlIHRpbWUtbGlrZSBwYXJhbWV0ZXIgaW50byBtaWxsaXNlY29uZCBudW1iZXJcbi8vICcwLjRzJyAtPiA0MFxuZnVuY3Rpb24gZ2V0TWlsbGlzZWNvbmRzKCB0aW1lICkge1xuICBpZiAoIHR5cGVvZiB0aW1lID09ICdudW1iZXInICkge1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIHZhciBtYXRjaGVzID0gdGltZS5tYXRjaCggLyheXFxkKlxcLj9cXGQqKShcXHcqKS8gKTtcbiAgdmFyIG51bSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1sxXTtcbiAgdmFyIHVuaXQgPSBtYXRjaGVzICYmIG1hdGNoZXNbMl07XG4gIGlmICggIW51bS5sZW5ndGggKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbnVtID0gcGFyc2VGbG9hdCggbnVtICk7XG4gIHZhciBtdWx0ID0gbXNVbml0c1sgdW5pdCBdIHx8IDE7XG4gIHJldHVybiBudW0gKiBtdWx0O1xufVxuXG4vLyAtLS0tLSBmaW4gLS0tLS0gLy9cblxuLy8gYmFjayBpbiBnbG9iYWxcbk91dGxheWVyLkl0ZW0gPSBJdGVtO1xuXG5yZXR1cm4gT3V0bGF5ZXI7XG5cbn0pKTtcbiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwiRXZFbWl0dGVyIiwiZ2V0U2l6ZSIsInV0aWxzIiwiSXRlbSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiT3V0bGF5ZXIiLCJmaXp6eVVJVXRpbHMiLCJjb25zb2xlIiwialF1ZXJ5Iiwibm9vcCIsIkdVSUQiLCJpbnN0YW5jZXMiLCJlbGVtZW50Iiwib3B0aW9ucyIsInF1ZXJ5RWxlbWVudCIsImdldFF1ZXJ5RWxlbWVudCIsImVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lc3BhY2UiLCIkZWxlbWVudCIsImV4dGVuZCIsImRlZmF1bHRzIiwib3B0aW9uIiwiaWQiLCJvdXRsYXllckdVSUQiLCJfY3JlYXRlIiwiaXNJbml0TGF5b3V0IiwiX2dldE9wdGlvbiIsImxheW91dCIsImNvbnRhaW5lclN0eWxlIiwicG9zaXRpb24iLCJpbml0TGF5b3V0Iiwib3JpZ2luTGVmdCIsIm9yaWdpblRvcCIsInJlc2l6ZSIsInJlc2l6ZUNvbnRhaW5lciIsInRyYW5zaXRpb25EdXJhdGlvbiIsImhpZGRlblN0eWxlIiwib3BhY2l0eSIsInRyYW5zZm9ybSIsInZpc2libGVTdHlsZSIsInByb3RvIiwicHJvdG90eXBlIiwib3B0cyIsIm9sZE9wdGlvbiIsImNvbXBhdE9wdGlvbnMiLCJ1bmRlZmluZWQiLCJob3Jpem9udGFsIiwibGF5b3V0SW5zdGFudCIsInJlbG9hZEl0ZW1zIiwic3RhbXBzIiwic3RhbXAiLCJzdHlsZSIsImNhbkJpbmRSZXNpemUiLCJiaW5kUmVzaXplIiwiaXRlbXMiLCJfaXRlbWl6ZSIsImNoaWxkcmVuIiwiZWxlbXMiLCJpdGVtRWxlbXMiLCJfZmlsdGVyRmluZEl0ZW1FbGVtZW50cyIsImkiLCJsZW5ndGgiLCJlbGVtIiwiaXRlbSIsInB1c2giLCJmaWx0ZXJGaW5kRWxlbWVudHMiLCJpdGVtU2VsZWN0b3IiLCJnZXRJdGVtRWxlbWVudHMiLCJtYXAiLCJfcmVzZXRMYXlvdXQiLCJfbWFuYWdlU3RhbXBzIiwiaXNJbnN0YW50IiwiX2lzTGF5b3V0SW5pdGVkIiwibGF5b3V0SXRlbXMiLCJfaW5pdCIsInNpemUiLCJfZ2V0TWVhc3VyZW1lbnQiLCJtZWFzdXJlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJIVE1MRWxlbWVudCIsIl9nZXRJdGVtc0ZvckxheW91dCIsIl9sYXlvdXRJdGVtcyIsIl9wb3N0TGF5b3V0IiwiZmlsdGVyIiwiaXNJZ25vcmVkIiwiX2VtaXRDb21wbGV0ZU9uSXRlbXMiLCJxdWV1ZSIsImZvckVhY2giLCJfZ2V0SXRlbUxheW91dFBvc2l0aW9uIiwiaXNMYXlvdXRJbnN0YW50IiwiX3Byb2Nlc3NMYXlvdXRRdWV1ZSIsIngiLCJ5IiwidXBkYXRlU3RhZ2dlciIsIm9iaiIsIl9wb3NpdGlvbkl0ZW0iLCJzdGFnZ2VyIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ29UbyIsIm1vdmVUbyIsImlzUmVzaXppbmdDb250YWluZXIiLCJfZ2V0Q29udGFpbmVyU2l6ZSIsIl9zZXRDb250YWluZXJNZWFzdXJlIiwid2lkdGgiLCJoZWlnaHQiLCJtZWFzdXJlIiwiaXNXaWR0aCIsImVsZW1TaXplIiwiaXNCb3JkZXJCb3giLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ1RvcCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJNYXRoIiwibWF4IiwiZXZlbnROYW1lIiwiX3RoaXMiLCJvbkNvbXBsZXRlIiwiZGlzcGF0Y2hFdmVudCIsImNvdW50IiwiZG9uZUNvdW50IiwidGljayIsIm9uY2UiLCJ0eXBlIiwiZXZlbnQiLCJhcmdzIiwiZW1pdEFyZ3MiLCJjb25jYXQiLCJlbWl0RXZlbnQiLCIkZXZlbnQiLCJFdmVudCIsInRyaWdnZXIiLCJpZ25vcmUiLCJnZXRJdGVtIiwidW5pZ25vcmUiLCJfZmluZCIsInVuc3RhbXAiLCJyZW1vdmVGcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsIm1ha2VBcnJheSIsIl9nZXRCb3VuZGluZ1JlY3QiLCJfbWFuYWdlU3RhbXAiLCJib3VuZGluZ1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfYm91bmRpbmdSZWN0IiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiX2dldEVsZW1lbnRPZmZzZXQiLCJ0aGlzUmVjdCIsIm9mZnNldCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsImhhbmRsZUV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImlzUmVzaXplQm91bmQiLCJ1bmJpbmRSZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25yZXNpemUiLCJkZWJvdW5jZU1ldGhvZCIsIm5lZWRzUmVzaXplTGF5b3V0IiwiaGFzU2l6ZXMiLCJpbm5lcldpZHRoIiwiYWRkSXRlbXMiLCJhcHBlbmRlZCIsInJldmVhbCIsInByZXBlbmRlZCIsInByZXZpb3VzSXRlbXMiLCJzbGljZSIsImhpZGUiLCJyZXZlYWxJdGVtRWxlbWVudHMiLCJnZXRJdGVtcyIsImhpZGVJdGVtRWxlbWVudHMiLCJyZW1vdmUiLCJyZW1vdmVJdGVtcyIsImRlc3Ryb3kiLCJyZW1vdmVEYXRhIiwiZGF0YSIsImNyZWF0ZSIsIkxheW91dCIsInN1YmNsYXNzIiwiaHRtbEluaXQiLCJicmlkZ2V0IiwiUGFyZW50IiwiU3ViQ2xhc3MiLCJhcHBseSIsImFyZ3VtZW50cyIsIk9iamVjdCIsIm1zVW5pdHMiLCJtcyIsInMiLCJ0aW1lIiwibWF0Y2hlcyIsIm1hdGNoIiwibnVtIiwidW5pdCIsInBhcnNlRmxvYXQiLCJtdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/outlayer/outlayer.js\n");

/***/ })

};
;